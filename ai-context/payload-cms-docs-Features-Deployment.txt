URL: https://payloadcms.com/docs/admin/overview

Payload dynamically generates a beautiful, fully type-safe Admin Panel to manage your users and data. It is highly performant, even with 100+ fields, and is translated in over 30 languages. Within the Admin Panel you can manage content, render your site, preview drafts, diff versions, and so much more.
The Admin Panel is designed to white-label your brand. You can endlessly customize and extend the Admin UI by swapping in your own Custom Components—everything from simple field labels to entire views can be modified or replaced to perfectly tailor the interface for your editors.
The Admin Panel is written in TypeScript and built with React using the Next.js App Router. It supports React Server Components, enabling the use of the Local API on the front-end. You can install Payload into any existing Next.js app in just one line and deploy it anywhere.
The Payload Admin Panel is designed to be as minimal and straightforward as possible to allow easy customization and control. Learn more.
The Admin Panel serves as the entire HTTP layer for Payload, providing a full CRUD interface for your app. This means that both the REST and GraphQL APIs are simply Next.js Routes that exist directly alongside your front-end application.
Once you install Payload, the following files and directories will be created in your app:
If you are not familiar with Next.js project structure, you can learn more about it here.
As shown above, all Payload routes are nested within the (payload) route group. This creates a boundary between the Admin Panel and the rest of your application by scoping all layouts and styles. The layout.tsx file within this directory, for example, is where Payload manages the html tag of the document to set proper lang and dir attributes, etc.
The admin directory contains all the pages related to the interface itself, whereas the api and graphql directories contains all the routes related to the REST API and GraphQL API. All admin routes are easily configurable to meet your application's exact requirements.
Note: If you don't intend to use the Admin Panel, REST API, or GraphQL API, you can opt-out by simply deleting their corresponding directories within your Next.js app. The overhead, however, is completely constrained to these routes, and will not slow down or affect Payload outside when not in use.
Finally, the custom.scss file is where you can add or override globally-oriented styles in the Admin Panel, such as modify the color palette. Customizing the look and feel through CSS alone is a powerful feature of the Admin Panel, more on that here.
All auto-generated files will contain the following comments at the top of each file:
All options for the Admin Panel are defined in your Payload Config under the admin property:
The following options are available:
 Option                         
 Description                                                                                                                                     
 avatar 
 Set account profile picture. Options: gravatar, default or a custom React component.                                                        
 autoLogin 
 Used to automate log-in for dev and demonstration convenience. More details.                                      
 buildPath 
 Specify an absolute path for where to store the built Admin bundle used in production. Defaults to path.resolve(process.cwd(), 'build').      
 components 
 Component overrides that affect the entirety of the Admin Panel. More details.                                 
 custom 
 Any custom properties you wish to pass to the Admin Panel.                                                                                      
 dateFormat 
 The date format that will be used for all dates within the Admin Panel. Any valid date-fns format pattern can be used. 
 livePreview 
 Enable real-time editing for instant visual feedback of your front-end application. More details.                   
 meta 
 Base metadata to use for the Admin Panel. More details.                                                                           
 routes 
 Replace built-in Admin Panel routes with your own custom routes. More details.                                           
 suppressHydrationWarning 
 If set to true, suppresses React hydration mismatch warnings during the hydration of the root <html> tag. Defaults to false.              
 theme 
 Restrict the Admin Panel theme to use only one of your choice. Default is all.                                                                
 timezones 
 Configure the timezone settings for the admin panel. More details 
 user 
 The slug of the Collection that you want to allow to login to the Admin Panel. More details.                    
Reminder: These are the root-level options for the Admin Panel. You can also customize Collection Admin Options and Global Admin Options through their respective admin keys.
To specify which Collection to allow to login to the Admin Panel, pass the admin.user key equal to the slug of any auth-enabled Collection:
 Important:
The Admin Panel can only be used by a single auth-enabled Collection. To enable authentication for a Collection, simply set auth: true in the Collection's configuration. See Authentication for more information.
By default, if you have not specified a Collection, Payload will automatically provide a User Collection with access to the Admin Panel. You can customize or override the fields and settings of the default User Collection by adding your own Collection with slug: 'users'. Doing this will force Payload to use your provided User Collection instead of its default version.
You can use whatever Collection you'd like to access the Admin Panel as long as the Collection supports Authentication. It doesn't need to be called users. For example, you may wish to have two Collections that both support authentication:
To do this, specify admin: { user: 'admins' } in your config. This will provide access to the Admin Panel to only admins. Any users authenticated as customers will be prevented from accessing the Admin Panel. See Access Control for full details.
It is also possible to allow multiple user types into the Admin Panel with limited permissions, known as role-based access control (RBAC). For example, you may wish to have two roles within the admins Collection:
To do this, add a roles or similar field to your auth-enabled Collection, then use the access.admin property to grant or deny access based on the value of that field. See Access Control for full details. For a complete, working example of role-based access control, check out the official Auth Example.
You have full control over the routes that Payload binds itself to. This includes both Root-level Routes such as the REST API, and Admin-level Routes such as the user's account page. You can customize these routes to meet the needs of your application simply by specifying the desired paths in your config.
Root-level routes are those that are not behind the /admin path, such as the REST API and GraphQL API, or the root path of the Admin Panel itself.
To customize root-level routes, use the routes property in your Payload Config:
The following options are available:
 Option              
 Default route         
 Description                                       
 admin 
 /admin 
 The Admin Panel itself.                           
 api 
 /api 
 The REST API base path.   
 graphQL 
 /graphql 
 The GraphQL API base path. 
 graphQLPlayground 
 /graphql-playground 
 The GraphQL Playground.                           
Tip: You can easily add new routes to the Admin Panel through Custom Endpoints and Custom Views.
You can change the Root-level Routes as needed, such as to mount the Admin Panel at the root of your application.
Changing Root-level Routes also requires a change to Project Structure to match the new route. For example, if you set routes.admin to /, you would need to completely remove the admin directory from the project structure:
Note: If you set Root-level Routes before auto-generating the Admin Panel via create-payload-app, your Project Structure will already be set up correctly.
Admin-level routes are those behind the /admin path. These are the routes that are part of the Admin Panel itself, such as the user's account page, the login page, etc.
To customize admin-level routes, use the admin.routes property in your Payload Config:
The following options are available:
 Option            
 Default route        
 Description                               
 account 
 /account 
 The user's account page.                  
 createFirstUser 
 /create-first-user 
 The page to create the first user.        
 forgot 
 /forgot 
 The password reset page.                  
 inactivity 
 /logout-inactivity 
 The page to redirect to after inactivity. 
 login 
 /login 
 The login page.                           
 logout 
 /logout 
 The logout page.                          
 reset 
 /reset 
 The password reset page.                  
 unauthorized 
 /unauthorized 
 The unauthorized page.                    
Note: You can also swap out entire views out for your own, using the admin.views property of the Payload Config. See Custom Views for more information.
The Payload Admin Panel is translated in over 30 languages and counting. Languages are automatically detected based on the user's browser and used by the Admin Panel to display all text in that language. If no language was detected, or if the user's language is not yet supported, English will be chosen. Users can easily specify their language by selecting one from their account page. See I18n for more information.
Users in the Admin Panel have the ability to choose between light mode and dark mode for their editing experience. Users can select their preferred theme from their account page. Once selected, it is saved to their user's preferences and persisted across sessions and devices. If no theme was selected, the Admin Panel will automatically detect the operation system's theme and use that as the default.
The admin.timezones configuration allows you to configure timezone settings for the Admin Panel. You can customise the available list of timezones and in the future configure the default timezone for the Admin Panel and for all users.
The following options are available:
 Option               
 Description                                                                                                     
 supportedTimezones 
 An array of label/value options for selectable timezones where the value is the IANA name eg. America/Detroit 
 defaultTimezone 
 The value of the default selected timezone. eg. America/Los_Angeles 
We validate the supported timezones array by checking the value against the list of IANA timezones supported via the Intl API, specifically Intl.supportedValuesOf('timeZone').
Important You must enable timezones on each individual date field via timezone: true. See Date Fields for more information.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/admin/preview

Preview is a feature that allows you to generate a direct link to your front-end application. When enabled, a "preview" button will appear on the Edit View within the Admin Panel with an href pointing to the URL you provide. This will provide your editors with a quick way of navigating to the front-end application where that Document's data is represented. Otherwise, they'd have to determine that URL themselves which is not always straightforward especially in complex apps.
The Preview feature can also be used to achieve something known as "Draft Preview". With Draft Preview, you can navigate to your front-end application and enter "draft mode", where your queries are modified to fetch draft content instead of published content. This is useful for seeing how your content will look before being published. More details.
Note: Preview is different than Live Preview. Live Preview loads your app within an iframe and renders it in the Admin Panel allowing you to see changes in real-time. Preview, on the other hand, allows you to generate a direct link to your front-end application.
To add Preview, pass a function to the admin.preview property in any Collection Config or Global Config:
The preview function resolves to a string that points to your front-end application with additional URL parameters. This can be an absolute URL or a relative path, and can run async if needed.
The following arguments are provided to the preview function:
 Path          
 Description                                                                                
 doc 
 The data of the Document being edited. This includes changes that have not yet been saved. 
 options 
 An object with additional properties.                                                      
The options object contains the following properties:
 Path         
 Description                                           
 locale 
 The current locale of the Document being edited.      
 req 
 The Payload Request object.                           
 token 
 The JWT token of the currently authenticated in user. 
If your application requires a fully qualified URL, such as within deploying to Vercel Preview Deployments, you can use the req property to build this URL:
The Preview feature can be used to achieve "Draft Preview". After clicking the preview button from the Admin Panel, you can enter into "draft mode" within your front-end application. This will allow you to adjust your page queries to include the draft: true param. When this param is present on the request, Payload will send back a draft document as opposed to a published one based on the document's _status field.
To enter draft mode, the URL provided to the preview function can point to a custom endpoint in your front-end application that sets a cookie or session variable to indicate that draft mode is enabled. This is framework specific, so the mechanisms here very from framework to framework although the underlying concept is the same.
If you're using Next.js, you can do the following code to enter Draft Mode.
First, format your admin.preview function to point to a custom endpoint that you'll open on your front-end. This URL should include a few key query search params:
Then, create an API route that verifies the preview secret, authenticates the user, and enters draft mode:
/app/preview/route.ts
Finally, in your front-end application, you can detect draft mode and adjust your queries to include drafts:
/app/[slug]/page.tsx
Note: For fully working example of this, check of the official Draft Preview Example in the Examples Directory.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/admin/locked-documents

Document locking in Payload ensures that only one user at a time can edit a document, preventing data conflicts and accidental overwrites. When a document is locked, other users are prevented from making changes until the lock is released, ensuring data integrity in collaborative environments.
The lock is automatically triggered when a user begins editing a document within the Admin Panel and remains in place until the user exits the editing view or the lock expires due to inactivity.
When a user starts editing a document, Payload locks it for that user. If another user attempts to access the same document, they will be notified that it is currently being edited. They can then choose one of the following options:
The lock will automatically expire after a set period of inactivity, configurable using the duration property in the lockDocuments configuration, after which others can resume editing.
{' '} Note: If your application does not require document locking, you can disable this feature for any collection or global by setting the lockDocuments property to false.{' '}
The lockDocuments property exists on both the Collection Config and the Global Config. Document locking is enabled by default, but you can customize the lock duration or turn off the feature for any collection or global.
Here's an example configuration for document locking:
 Option              
 Description                                                                                                                                                                    
 lockDocuments 
 Enables or disables document locking for the collection or global. By default, document locking is enabled. Set to an object to configure, or set to false to disable locking. 
 duration 
 Specifies the duration (in seconds) for how long a document remains locked without user interaction. The default is 300 seconds (5 minutes).                                   
Document locking affects both the Local and REST APIs, ensuring that if a document is locked, concurrent users will not be able to perform updates or deletes on that document (including globals). If a user attempts to update or delete a locked document, they will receive an error.
Once the document is unlocked or the lock duration has expired, other users can proceed with updates or deletes as normal.
For operations like update and delete, Payload includes an overrideLock option. This boolean flag, when set to false, enforces document locks, ensuring that the operation will not proceed if another user currently holds the lock.
By default, overrideLock is set to true, which means that document locks are ignored, and the operation will proceed even if the document is locked. To enforce locks and prevent updates or deletes on locked documents, set overrideLock: false.
This option is particularly useful in scenarios where administrative privileges or specific workflows require you to override the lock and ensure the operation is completed.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/admin/react-hooks

Payload provides a variety of powerful React Hooks that can be used within your own Custom Components, such as Custom Fields. With them, you can interface with Payload itself to build just about any type of complex customization you can think of.
Reminder: All Custom Components are React Server Components by default. Hooks, on the other hand, are only available in client-side environments. To use hooks, ensure your component is a client component.
The useField hook is used internally within all field components. It manages sending and receiving a field's state from its parent form. When you build a Custom Field Component, you will be responsible for sending and receiving the field's value to and from the form yourself.
To do so, import the useField hook as follows:
The useField hook accepts the following arguments:
 Property          
 Description                                                                                                                                                                                      
 path 
 If you do not provide a path, name will be used instead. This is the path to the field in the form data.                                                                                     
 validate 
 A validation function executed client-side before submitting the form to the server. Different than Field-level Validation which runs strictly on the server. 
 disableFormData 
 If true, the field will not be included in the form data when the form is submitted.                                                                                                           
 hasRows 
 If true, the field will be treated as a field with rows. This is useful for fields like array and blocks.                                                                                  
The useField hook returns the following object:
There are times when a custom field component needs to have access to data from other fields, and you have a few options to do so. The useFormFields hook is a powerful and highly performant way to retrieve a form's field state, as well as to retrieve the dispatchFields method, which can be helpful for setting other fields' form states from anywhere within a form.
This hook is great for retrieving only certain fields from form state because it ensures that it will only cause a rerender when the items that you ask for change.
Thanks to the awesome package use-context-selector, you can retrieve a specific field's state easily. This is ideal because you can ensure you have an up-to-date field state, and your component will only re-render when that field's state changes.
You can pass a Redux-like selector into the hook, which will ensure that you retrieve only the field that you want. The selector takes an argument with type of [fields: Fields, dispatch: React.Dispatch<Action>]].
To retrieve more than one field, you can use the useAllFormFields hook. Your component will re-render when any field changes, so use this hook only if you absolutely need to. Unlike the useFormFields hook, this hook does not accept a "selector", and it always returns an array with type of [fields: Fields, dispatch: React.Dispatch<Action>]].
You can do lots of powerful stuff by retrieving the full form state, like using built-in helper functions to reduce field state to values only, or to retrieve sibling data by path.
If you are building a Custom Component, then you should use setValue which is returned from the useField hook to programmatically set your field's value. But if you're looking to update another field's value, you can use dispatchFields returned from useAllFormFields.
You can send the following actions to the dispatchFields function.
 Action                 
 Description                                                                
 ADD_ROW 
 Adds a row of data (useful in array / block field data)                    
 DUPLICATE_ROW 
 Duplicates a row of data (useful in array / block field data)              
 MODIFY_CONDITION 
 Updates a field's conditional logic result (true / false)                  
 MOVE_ROW 
 Moves a row of data (useful in array / block field data)                   
 REMOVE 
 Removes a field from form state                                            
 REMOVE_ROW 
 Removes a row of data from form state (useful in array / block field data) 
 REPLACE_STATE 
 Completely replaces form state                                             
 UPDATE 
 Update any property of a specific field's state                            
To see types for each action supported within the dispatchFields hook, check out the Form types here.
The useForm hook can be used to interact with the form itself, and sends back many methods that can be used to reactively fetch form state without causing rerenders within your components each time a field is changed. This is useful if you have action-based callbacks that your components fire, and need to interact with form state based on a user action.
 Warning:
This hook is optimized to avoid causing rerenders when fields change, and as such, its fields property will be out of date. You should only leverage this hook if you need to perform actions against the form in response to your users' actions. Do not rely on its returned "fields" as being up-to-date. They will be removed from this hook's response in an upcoming version.
The useForm hook returns an object with the following properties:
fields
Deprecated. This property cannot be relied on as up-to-date.
submit
Method to trigger the form to submit
dispatchFields
Dispatch actions to the form field state
validateForm
Trigger a validation of the form state
createFormData
Create a multipart/form-data object from the current form's state
disabled
Boolean denoting whether or not the form is disabled
getFields
Gets all fields from state
getField
Gets a single field from state by path
getData
Returns the data stored in the form
getSiblingData
Returns form sibling data for the given field path
setModified
Set the form's modified state
setProcessing
Set the form's processing state
setSubmitted
Set the form's submitted state
formRef
The ref from the form HTML element
reset
Method to reset the form to its initial state
addFieldRow
Method to add a row on an array or block field
removeFieldRow
Method to remove a row from an array or block field
replaceFieldRow
Method to replace a row from an array or block field
The useDocumentForm hook works the same way as the useForm hook, but it always gives you access to the top-level Form of a document. This is useful if you need to access the document's Form context from within a child Form.
An example where this could happen would be custom components within lexical blocks, as lexical blocks initialize their own child Form.
The useCollapsible hook allows you to control parent collapsibles:
 Property                  
 Description                                                                                                   
 isCollapsed 
 State of the collapsible. true if open, false if collapsed.                                               
 isVisible 
 If nested, determine if the nearest collapsible is visible. true if no parent is closed, false otherwise. 
 toggle 
 Toggles the state of the nearest collapsible.                                                                 
 isWithinCollapsible 
 Determine when you are within another collapsible.                                                            
Example:
The useDocumentInfo hook provides information about the current document being edited, including the following:
 Property                           
 Description                                                                                                                                      
 action 
 The URL attached to the action attribute on the underlying form element, which specifies where to send the form data when the form is submitted. 
 apiURL 
 The API URL for the current document.                                                                                                            
 collectionSlug 
 The slug of the collection if editing a collection document.                                                                                     
 currentEditor 
 The user currently editing the document.                                                                                                         
 docConfig 
 Either the Collection or Global config of the document, depending on what is being edited.                                                       
 docPermissions 
 The current document's permissions. Fallback to collection permissions when no id is present.                                                    
 documentIsLocked 
 Whether the document is currently locked by another user. More details.                                                    
 getDocPermissions 
 Method to retrieve document-level permissions.                                                                                                   
 getDocPreferences 
 Method to retrieve document-level user preferences. More details.                                                               
 globalSlug 
 The slug of the global if editing a global document.                                                                                             
 hasPublishedDoc 
 Whether the document has a published version.                                                                                                    
 hasPublishPermission 
 Whether the current user has permission to publish the document.                                                                                 
 hasSavePermission 
 Whether the current user has permission to save the document.                                                                                    
 id 
 If the doc is a collection, its ID will be returned.                                                                                             
 incrementVersionCount 
 Method to increment the version count of the document.                                                                                           
 initialData 
 The initial data of the document.                                                                                                                
 isEditing 
 Whether the document is being edited (as opposed to created).                                                                                    
 isInitializing 
 Whether the document info is still initializing.                                                                                                 
 isLocked 
 Whether the document is locked. More details.                                                                              
 lastUpdateTime 
 Timestamp of the last update to the document.                                                                                                    
 mostRecentVersionIsAutosaved 
 Whether the most recent version is an autosaved version.                                                                                         
 preferencesKey 
 The preferences key to use when interacting with document-level user preferences. More details.                               
 savedDocumentData 
 The saved data of the document.                                                                                                                  
 setDocFieldPreferences 
 Method to set preferences for a specific field. More details.                                                                   
 setDocumentTitle 
 Method to set the document title.                                                                                                                
 setHasPublishedDoc 
 Method to update whether the document has been published.                                                                                        
 title 
 The title of the document.                                                                                                                       
 unlockDocument 
 Method to unlock a document. More details.                                                                                 
 unpublishedVersionCount 
 The number of unpublished versions of the document.                                                                                              
 updateDocumentEditor 
 Method to update who is currently editing the document. More details.                                                      
 updateSavedDocumentData 
 Method to update the saved document data.                                                                                                        
 uploadStatus 
 Status of any uploads in progress ('idle', 'uploading', or 'failed').                                                                            
 versionCount 
 The current version count of the document.                                                                                                       
Example:
The useListQuery hook is used to subscribe to the data, current query, and other properties used within the List View. You can use this hook within any Custom Component rendered within the List View.
The useListQuery hook returns an object with the following properties:
 Property                  
 Description                                                                            
 data 
 The data that is being displayed in the List View.                                     
 defaultLimit 
 The default limit of items to display in the List View.                                
 defaultSort 
 The default sort order of items in the List View.                                      
 handlePageChange 
 A method to handle page changes in the List View.                                      
 handlePerPageChange 
 A method to handle per page changes in the List View.                                  
 handleSearchChange 
 A method to handle search changes in the List View.                                    
 handleSortChange 
 A method to handle sort changes in the List View.                                      
 handleWhereChange 
 A method to handle where changes in the List View.                                     
 modified 
 Whether the query has been changed from its Query Preset. 
 query 
 The current query that is being used to fetch the data in the List View.               
The useSelection hook provides information on the selected rows in the List view as well as helper methods to simplify selection. The useSelection hook returns an object with the following properties:
 Property             
 Description                                                                                                                                                               
 count 
 The number of currently selected rows.                                                                                                                                    
 getQueryParams 
 A function that generates a query string based on the current selection state and optional additional filtering parameters.                                               
 selectAll 
 An enum value representing the selection range: 'allAvailable', 'allInPage', 'none', and 'some'. The enum, SelectAllStatus, is exported for easier comparisons. 
 selected 
 A map of document id keys and boolean values representing their selection status.                                                                                         
 setSelection 
 A function that toggles the selection status of a document row.                                                                                                           
 toggleAll 
 A function that toggles selection for all documents on the current page or selects all available documents when passed true.                                            
 totalDocs 
 The number of total documents in the collection.                                                                                                                          
Example:
In any Custom Component you can get the selected locale object with the useLocale hook. useLocale gives you the full locale object, consisting of a label, rtl(right-to-left) property, and then code. Here is a simple example:
Useful to retrieve info about the currently logged in user as well as methods for interacting with it. It sends back an object with the following properties:
 Property                 
 Description                                                                             
 user 
 The currently logged in user                                                            
 logOut 
 A method to log out the currently logged in user                                        
 refreshCookie 
 A method to trigger the silent refreshing of a user's auth token                        
 setToken 
 Set the token of the user, to be decoded and used to reset the user and token in memory 
 token 
 The logged in user's token (useful for creating preview links, etc.)                    
 refreshPermissions 
 Load new permissions (useful when content that effects permissions has been changed)    
 permissions 
 The permissions of the current user                                                     
Used to retrieve the Payload Client Config.
If you need to retrieve a specific collection or global config by its slug, getEntityConfig is the most efficient way to do so:
Sends back how many editing levels "deep" the current component is. Edit depth is relevant while adding new documents / editing documents in modal windows and other cases.
Returns methods to set and get user preferences. More info can be found here.
Returns the currently selected theme (light, dark or auto), a set function to update it and a boolean autoMode, used to determine if the theme value should be set automatically based on the user's device preferences.
Returns methods to manipulate table columns
The useDocumentEvents hook provides a way of subscribing to cross-document events, such as updates made to nested documents within a drawer. This hook will report document events that are outside the scope of the document currently being edited. This hook provides the following:
 Property               
 Description                                                                                                                             
 mostRecentUpdate 
 An object containing the most recently updated document. It contains the entitySlug, id (if collection), and updatedAt properties 
 reportUpdate 
 A method used to report updates to documents. It accepts the same arguments as the mostRecentUpdate property.                         
Example:
Right now the useDocumentEvents hook only tracks recently updated documents, but in the future it will track more document-related events as needed, such as document creation, deletion, etc.
The useStepNav hook provides a way to change the step-nav breadcrumb links in the app header.
 Property         
 Description                                                                      
 setStepNav 
 A state setter function which sets the stepNav array.                          
 stepNav 
 A StepNavItem array where each StepNavItem has a label and optionally a url. 
Example:
The usePayloadAPI hook is a useful tool for making REST API requests to your Payload instance and handling responses reactively. It allows you to fetch and interact with data while automatically updating when parameters change.
This hook returns an array with two elements:
Example:
Arguments:
 Property      
 Description                                                                                     
 url 
 The API endpoint to fetch data from. Relative URLs will be prefixed with the Payload API route. 
 options 
 An object containing initial request parameters and initial state configuration.                
The options argument accepts the following properties:
 Property            
 Description                                                                                         
 initialData 
 Uses this data instead of making an initial request. If not provided, the request runs immediately. 
 initialParams 
 Defines the initial parameters to use in the request. Defaults to an empty object {}.             
Returned Value:
The first item in the returned array is an object containing the following properties:
 Property        
 Description                                              
 data 
 The API response data.                                   
 isError 
 A boolean indicating whether the request failed.         
 isLoading 
 A boolean indicating whether the request is in progress. 
The second item is an object with the following methods:
 Property        
 Description                                                 
 setParams 
 Updates request parameters, triggering a refetch if needed. 
The setParams function can be used to update the request and trigger a refetch:
This is useful for scenarios where you need to trigger another fetch regardless of the url argument changing.
Route transitions are useful in showing immediate visual feedback to the user when navigating between pages. This is especially useful on slow networks when navigating to data heavy or process intensive pages.
By default, any instances of Link from @payloadcms/ui will trigger route transitions dy default.
You can also trigger route transitions programmatically, such as when using router.push from next/router. To do this, wrap your function calls with the startRouteTransition method provided by the useRouteTransition hook.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/admin/customizing-css

Customizing the Payload Admin Panel through CSS alone is one of the easiest and most powerful ways to customize the look and feel of the dashboard. To allow for this level of customization, Payload:
To customize the CSS within the Admin UI, determine scope and change you'd like to make, and then add your own CSS or SCSS to the configuration as needed.
Global CSS refers to the CSS that is applied to the entire Admin Panel. This is where you can have a significant impact to the look and feel of the Admin UI through just a few lines of code.
You can add your own global CSS through the root custom.scss file of your app. This file is loaded into the root of the Admin Panel and can be used to inject custom selectors or styles however needed.
Here is an example of how you might target the Dashboard View and change the background color:
Note: If you are building Custom Components, it is best to import your own stylesheets directly into your components, rather than using the global stylesheet. You can continue to use the CSS library as needed.
All Payload CSS is encapsulated inside CSS layers under @layer payload-default. Any custom css will now have the highest possible specificity.
We have also provided a layer @layer payload if you want to use layers and ensure that your styles are applied after payload.
To override existing styles in a way that the previous rules of specificity would be respected you can use the default layer like so
You can re-use Payload's SCSS variables and utilities in your own stylesheets by importing it from the UI package.
To make it as easy as possible for you to override default styles, Payload uses BEM naming conventions for all CSS within the Admin UI. If you provide your own CSS, you can override any built-in styles easily, including targeting nested components and their various component states.
You can also override Payload's built-in CSS Variables. These variables are widely consumed by the Admin Panel, so modifying them has a significant impact on the look and feel of the Admin UI.
The following variables are defined and can be overridden:
For an up-to-date, comprehensive list of all available variables, please refer to the Source Code.
Warning: If you're overriding colors or theme elevations, make sure to consider how your changes will affect dark mode.
Colors are designed to automatically adapt to theme of the Admin Panel. By default, Payload automatically overrides all --theme-elevation colors and inverts all success / warning / error shades to suit dark mode. We also update some base theme variables like --theme-bg, --theme-text, etc.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/admin/preferences

As your users interact with the Admin Panel, you might want to store their preferences in a persistent manner, so that when they revisit the Admin Panel in a different session or from a different device, they can pick right back up where they left off.
Out of the box, Payload handles the persistence of your users' preferences in a handful of ways, including:
 Important:
All preferences are stored on an individual user basis. Payload automatically recognizes the user that is reading or setting a preference via all provided authentication methods.
This API is used significantly for internal operations of the Admin Panel, as mentioned above. But, if you're building your own React components for use in the Admin Panel, you can allow users to set their own preferences in correspondence to their usage of your components. For example:
Payload automatically creates an internally used payload-preferences Collection that stores user preferences. Each document in the payload-preferences Collection contains the following shape:
 Key               
 Value                                                             
 id 
 A unique ID for each preference stored.                           
 key 
 A unique key that corresponds to the preference.                
 user.value 
 The ID of the user that is storing its preference.              
 user.relationTo 
 The slug of the Collection that the user is logged in as.     
 value 
 The value of the preference. Can be any data shape that you need. 
 createdAt 
 A timestamp of when the preference was created.                   
 updatedAt 
 A timestamp set to the last time the preference was updated.      
Preferences are available to both GraphQL and REST APIs.
The Payload Admin Panel offers a usePreferences hook. The hook is only meant for use within the Admin Panel itself. It provides you with two methods:
This async method provides an easy way to retrieve a user's preferences by key. It will return a promise containing the resulting preference value.
Arguments
Also async, this method provides you with an easy way to set a user preference. It returns void.
Arguments:
Here is an example for how you can utilize usePreferences within your custom Admin Panel components. Note - this example is not fully useful and is more just a reference for how to utilize the Preferences API. In this case, we are demonstrating how to set and retrieve a user's last used colors history within a ColorPicker or similar type component.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/admin/metadata

Every page within the Admin Panel automatically receives dynamic, auto-generated metadata derived from live document data, the user's current locale, and more. This includes the page title, description, og:image, etc. and requires no additional configuration.
Metadata is fully configurable at the root level and cascades down to individual collections, documents, and custom views. This allows for the ability to control metadata on any page with high precision, while also providing sensible defaults.
All metadata is injected into Next.js' generateMetadata function. This used to generate the <head> of pages within the Admin Panel. All metadata options that are available in Next.js are exposed by Payload.
Within the Admin Panel, metadata can be customized at the following levels:
All of these types of metadata share a similar structure, with a few key differences on the Root level. To customize metadata, consult the list of available scopes. Determine the scope that corresponds to what you are trying to accomplish, then author your metadata within the Payload Config accordingly.
Root Metadata is the metadata that is applied to all pages within the Admin Panel. This is where you can control things like the suffix appended onto each page's title, the favicon displayed in the browser's tab, and the Open Graph data that is used when sharing the Admin Panel on social media.
To customize Root Metadata, use the admin.meta key in your Payload Config:
The following options are available for Root Metadata:
 Key                  
 Type                                    
 Description                                                                                                                                                                                                                                                               
 defaultOGImageType 
 dynamic (default), static, or off 
 The type of default OG image to use. If set to dynamic, Payload will use Next.js image generation to create an image with the title of the page. If set to static, Payload will use the defaultOGImage URL. If set to off, Payload will not generate an OG image. 
 titleSuffix 
 string 
 A suffix to append to the end of the title of every page. Defaults to "- Payload".                                                                                                                                                                                        
 [keyof Metadata] 
 unknown 
 Any other properties that Next.js supports within the generateMetadata function. More details.                                                                                                 
Reminder: These are the root-level options for the Admin Panel. You can also customize metadata on the Collection, Global, and Document levels through their respective configs.
The Icons Config corresponds to the <link> tags that are used to specify icons for the Admin Panel. The icons key is an array of objects, each of which represents an individual icon. Icons are differentiated from one another by their rel attribute, which specifies the relationship between the document and the icon.
The most common icon type is the favicon, which is displayed in the browser tab. This is specified by the rel attribute icon. Other common icon types include apple-touch-icon, which is used by Apple devices when the Admin Panel is saved to the home screen, and mask-icon, which is used by Safari to mask the Admin Panel icon.
To customize icons, use the admin.meta.icons property in your Payload Config:
For a full list of all available Icon options, see the Next.js documentation.
Open Graph metadata is a set of tags that are used to control how URLs are displayed when shared on social media platforms. Open Graph metadata is automatically generated by Payload, but can be customized at the Root level.
To customize Open Graph metadata, use the admin.meta.openGraph property in your Payload Config:
For a full list of all available Open Graph options, see the Next.js documentation.
Setting the robots property will allow you to control the robots meta tag that is rendered within the <head> of the Admin Panel. This can be used to control how search engines index pages and displays them in search results.
By default, the Admin Panel is set to prevent search engines from indexing pages within the Admin Panel.
To customize the Robots Config, use the admin.meta.robots property in your Payload Config:
For a full list of all available Robots options, see the Next.js documentation.
While setting meta tags via admin.meta.robots can prevent search engines from indexing web pages, it does not prevent them from being crawled.
To prevent your pages from being crawled altogether, add a robots.txt file to your root directory.
Note: If you've customized the path to your Admin Panel via config.routes, be sure to update the Disallow directive to match your custom path.
Collection Metadata is the metadata that is applied to all pages within any given Collection within the Admin Panel. This metadata is used to customize the title and description of all views within any given Collection, unless overridden by the view itself.
To customize Collection Metadata, use the admin.meta key within your Collection Config:
The Collection Meta config has the same options as the Root Metadata config.
Global Metadata is the metadata that is applied to all pages within any given Global within the Admin Panel. This metadata is used to customize the title and description of all views within any given Global, unless overridden by the view itself.
To customize Global Metadata, use the admin.meta key within your Global Config:
The Global Meta config has the same options as the Root Metadata config.
View Metadata is the metadata that is applied to specific Views within the Admin Panel. This metadata is used to customize the title and description of a specific view, overriding any metadata set at the Root, Collection, or Global level.
To customize View Metadata, use the meta key within your View Config:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/custom-components/overview

The Payload Admin Panel is designed to be as minimal and straightforward as possible to allow for easy customization and full control over the UI. In order for Payload to support this level of customization, Payload provides a pattern for you to supply your own React components through your Payload Config.
All Custom Components in Payload are React Server Components by default. This enables the use of the Local API directly on the front-end. Custom Components are available for nearly every part of the Admin Panel for extreme granularity and control.
Note: Client Components continue to be fully supported. To use Client Components in your app, simply include the 'use client' directive. Payload will automatically detect and remove all non-serializable default props before rendering your component. More details.
There are four main types of Custom Components in Payload:
To swap in your own Custom Component, first determine the scope that corresponds to what you are trying to accomplish, consult the list of available components, then author your React component(s) accordingly.
As Payload compiles the Admin Panel, it checks your config for Custom Components. When detected, Payload either replaces its own default component with yours, or if none exists by default, renders yours outright. While there are many places where Custom Components are supported in Payload, each is defined in the same way using Component Paths.
To add a Custom Component, point to its file path in your Payload Config:
Note: All Custom Components can be either Server Components or Client Components, depending on the presence of the 'use client' directive at the top of the file.
In order to ensure the Payload Config is fully Node.js compatible and as lightweight as possible, components are not directly imported into your config. Instead, they are identified by their file path for the Admin Panel to resolve on its own.
Component Paths, by default, are relative to your project's base directory. This is either your current working directory, or the directory specified in config.admin.importMap.baseDir.
Components using named exports are identified either by appending # followed by the export name, or using the exportName property. If the component is the default export, this can be omitted.
In this example, we set the base directory to the src directory, and omit the /src/ part of our component path string.
While Custom Components are usually defined as a string, you can also pass in an object with additional options:
The following options are available:
 Property      
 Description                                                                                                                   
 clientProps 
 Props to be passed to the Custom Components if it's a Client Component. More details.                        
 exportName 
 Instead of declaring named exports using # in the component path, you can also omit them from path and pass them in here. 
 path 
 File path to the Custom Component. Named exports can be appended to the end of the path, separated by a #.                  
 serverProps 
 Props to be passed to the Custom Component if it's a Server Component. More details.                         
For details on how to build Custom Components, see Building Custom Components.
In order for Payload to make use of Component Paths, an "Import Map" is automatically generated at either src/app/(payload)/admin/importMap.js or app/(payload)/admin/importMap.js. This file contains every Custom Component in your config, keyed to their respective paths. When Payload needs to lookup a component, it uses this file to find the correct import.
The Import Map is automatically regenerated at startup and whenever Hot Module Replacement (HMR) runs, or you can run payload generate:importmap to manually regenerate it.
Using the config.admin.importMap.importMapFile property, you can override the location of the import map. This is useful if you want to place the import map in a different location, or if you want to use a custom file name.
If needed, custom items can be appended onto the Import Map. This is mostly only relevant for plugin authors who need to add a custom import that is not referenced in a known location.
To add a custom import to the Import Map, use the admin.dependencies property in your Payload Config:
All Custom Components in Payload are React Server Components by default. This enables the use of the Local API directly on the front-end, among other things.
To make building Custom Components as easy as possible, Payload automatically provides common props, such as the payload class and the i18n object. This means that when building Custom Components within the Admin Panel, you do not have to get these yourself.
Here is an example:
Each Custom Component receives the following props by default:
 Prop      
 Description                                 
 payload 
 The Payload class. 
 i18n 
 The i18n object.   
Reminder: All Custom Components also receive various other props that are specific to the component being rendered. See Root Components, Collection Components, Global Components, or Field Components for a complete list of all default props per component.
It is also possible to pass custom props to your Custom Components. To do this, you can use either the clientProps or serverProps properties depending on whether your prop is serializable, and whether your component is a Server or Client Component.
Here is how your component might receive this prop:
All Custom Components in Payload are React Server Components by default, however, it is possible to use Client Components by simply adding the 'use client' directive at the top of your file. Payload will automatically detect and remove all non-serializable default props before rendering your component.
Reminder: Client Components cannot be passed non-serializable props. If you are rendering your Client Component from within a Server Component, ensure that its props are serializable.
From any Server Component, the Payload Config can be accessed directly from the payload prop:
But, the Payload Config is non-serializable by design. It is full of custom validation functions and more. This means that the Payload Config, in its entirety, cannot be passed directly to Client Components.
For this reason, Payload creates a Client Config and passes it into the Config Provider. This is a serializable version of the Payload Config that can be accessed from any Client Component via the useConfig hook:
See Using Hooks for more details.
Similarly, all Field Components automatically receive their respective Field Config through props.
Within Server Components, this prop is named field:
Within Client Components, this prop is named clientField because its non-serializable props have been removed:
All Custom Components can support language translations to be consistent with Payload's I18n. This will allow your Custom Components to display the correct language based on the user's preferences.
To do this, first add your translation resources to the I18n Config. Then from any Server Component, you can translate resources using the getTranslation function from @payloadcms/translations.
All Server Components automatically receive the i18n object as a prop by default:
The best way to do this within a Client Component is to import the useTranslation hook from @payloadcms/ui:
See the Hooks documentation for a full list of available hooks.
All Custom Views can support multiple locales to be consistent with Payload's Localization feature. This can be used to scope API requests, etc.
All Server Components automatically receive the locale object as a prop by default:
The best way to do this within a Client Component is to import the useLocale hook from @payloadcms/ui:
See the Hooks documentation for a full list of available hooks.
To make it easier to build your Custom Components, you can use Payload's built-in React Hooks in any Client Component. For example, you might want to interact with one of Payload's many React Contexts. To do this, you can use one of the many hooks available depending on your needs.
See the Hooks documentation for a full list of available hooks.
Payload has a robust CSS Library that you can use to style your Custom Components to match to Payload's built-in styling. This will ensure that your Custom Components integrate well into the existing design system. This will make it so they automatically adapt to any theme changes that might occur.
To apply custom styles, simply import your own .css or .scss file into your Custom Component:
Then to colorize your Custom Component's background, for example, you can use the following CSS:
Payload also exports its SCSS library for reuse which includes mixins, etc. To use this, simply import it as follows into your .scss file:
Note: You can also drill into Payload's own component styles, or easily apply global, app-wide CSS. More on that here.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/custom-components/root-components

Root Components are those that affect the Admin Panel at a high-level, such as the logo or the main nav. You can swap out these components with your own Custom Components to create a completely custom look and feel.
When combined with Custom CSS, you can create a truly unique experience for your users, such as white-labeling the Admin Panel to match your brand.
To override Root Components, use the admin.components property at the root of your Payload Config:
The following options are available:
 Path              
 Description                                                                                                                                                              
 actions 
 An array of Custom Components to be rendered within the header of the Admin Panel, providing additional interactivity and functionality. More details.     
 afterDashboard 
 An array of Custom Components to inject into the built-in Dashboard, after the default dashboard contents. More details.                            
 afterLogin 
 An array of Custom Components to inject into the built-in Login, after the default login form. More details.                                            
 afterNavLinks 
 An array of Custom Components to inject into the built-in Nav, after the links. More details.                                                        
 beforeDashboard 
 An array of Custom Components to inject into the built-in Dashboard, before the default dashboard contents. More details.                          
 beforeLogin 
 An array of Custom Components to inject into the built-in Login, before the default login form. More details.                                          
 beforeNavLinks 
 An array of Custom Components to inject into the built-in Nav, before the links themselves. More details.                                           
 graphics.Icon 
 The simplified logo used in contexts like the the Nav component. More details.                                                                        
 graphics.Logo 
 The full logo used in contexts like the Login view. More details.                                                                                     
 header 
 An array of Custom Components to be injected above the Payload header. More details.                                                                          
 logout.Button 
 The button displayed in the sidebar that logs the user out. More details.                                                                               
 Nav 
 Contains the sidebar / mobile menu in its entirety. More details.                                                                                                
 providers 
 Custom React Context providers that will wrap the entire Admin Panel. More details. 
 views 
 Override or create new views within the Admin Panel. More details.                                                                                     
For details on how to build Custom Components, see Building Custom Components.
Note: You can also use set Collection Components and Global Components in their respective configs.
Actions are rendered within the header of the Admin Panel. Actions are typically used to display buttons that add additional interactivity and functionality, although they can be anything you'd like.
To add an action, use the actions property in your admin.components config:
Here is an example of a simple Action component:
Note: You can also use add Actions to the Edit View and List View in their respective configs.
The beforeDashboard property allows you to inject Custom Components into the built-in Dashboard, before the default dashboard contents.
To add beforeDashboard components, use the admin.components.beforeDashboard property in your Payload Config:
Here is an example of a simple beforeDashboard component:
Similar to beforeDashboard, the afterDashboard property allows you to inject Custom Components into the built-in Dashboard, after the default dashboard contents.
To add afterDashboard components, use the admin.components.afterDashboard property in your Payload Config:
Here is an example of a simple afterDashboard component:
The beforeLogin property allows you to inject Custom Components into the built-in Login view, before the default login form.
To add beforeLogin components, use the admin.components.beforeLogin property in your Payload Config:
Here is an example of a simple beforeLogin component:
Similar to beforeLogin, the afterLogin property allows you to inject Custom Components into the built-in Login view, after the default login form.
To add afterLogin components, use the admin.components.afterLogin property in your Payload Config:
Here is an example of a simple afterLogin component:
The beforeNavLinks property allows you to inject Custom Components into the built-in Nav Component, before the nav links themselves.
To add beforeNavLinks components, use the admin.components.beforeNavLinks property in your Payload Config:
Here is an example of a simple beforeNavLinks component:
Similar to beforeNavLinks, the afterNavLinks property allows you to inject Custom Components into the built-in Nav, after the nav links.
To add afterNavLinks components, use the admin.components.afterNavLinks property in your Payload Config:
Here is an example of a simple afterNavLinks component:
The Nav property contains the sidebar / mobile menu in its entirety. Use this property to completely replace the built-in Nav with your own custom navigation.
To add a custom nav, use the admin.components.Nav property in your Payload Config:
Here is an example of a simple Nav component:
The Icon property is the simplified logo used in contexts like the Nav component. This is typically a small, square icon that represents your brand.
To add a custom icon, use the admin.components.graphics.Icon property in your Payload Config:
Here is an example of a simple Icon component:
The Logo property is the full logo used in contexts like the Login view. This is typically a larger, more detailed representation of your brand.
To add a custom logo, use the admin.components.graphic.Logo property in your Payload Config:
Here is an example of a simple Logo component:
The Header property allows you to inject Custom Components above the Payload header.
Examples of a custom header components might include an announcements banner, a notifications bar, or anything else you'd like to display at the top of the Admin Panel in a prominent location.
To add Header components, use the admin.components.header property in your Payload Config:
Here is an example of a simple Header component:
The logout.Button property is the button displayed in the sidebar that should log the user out when clicked.
To add a custom logout button, use the admin.components.logout.Button property in your Payload Config:
Here is an example of a simple logout.Button component:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/custom-components/custom-providers

As you add more and more Custom Components to your Admin Panel, you may find it helpful to add additional React Context(s) to your app. Payload allows you to inject your own context providers where you can export your own custom hooks, etc.
To add a Custom Provider, use the admin.components.providers property in your Payload Config:
Then build your Custom Provider as follows:
For details on how to build Custom Components, see Building Custom Components.
Reminder: React Context exists only within Client Components. This means they must include the use client directive at the top of their files and cannot contain server-only code. To use a Server Component here, simply wrap your Client Component with it.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/custom-components/custom-views

Views are the individual pages that make up the Admin Panel, such as the Dashboard, List View, and Edit View. One of the most powerful ways to customize the Admin Panel is to create Custom Views. These are Custom Components that can either replace built-in views or be entirely new.
There are four types of views within the Admin Panel:
To swap in your own Custom View, first determine the scope that corresponds to what you are trying to accomplish, consult the list of available components, then author your React component(s) accordingly.
To customize views, use the admin.components.views property in your Payload Config. This is an object with keys for each view you want to customize. Each key corresponds to the view you want to customize.
The exact list of available keys depends on the scope of the view you are customizing, depending on whether it's a Root View, Collection View, or Global View. Regardless of the scope, the principles are the same.
Here is an example of how to swap out a built-in view:
For more granular control, pass a configuration object instead. Payload exposes the following properties for each view:
 Property       
 Description                                                                                                                                                                         
 Component * 
 Pass in the component path that should be rendered when a user navigates to this route.                                                                                             
 path *      
 Any valid URL path or array of paths that path-to-regexp understands.                                                              
 exact 
 Boolean. When true, will only match if the path matches the usePathname() exactly.                                                                                                
 strict 
 When true, a path that has a trailing slash will only match a location.pathname with a trailing slash. This has no effect when there are additional URL segments in the pathname. 
 sensitive 
 When true, will match if the path is case sensitive.                                                                                                                                
 meta 
 Page metadata overrides to apply to this view within the Admin Panel. More details.                                                                            
* An asterisk denotes that a property is required.
To add a new view to the Admin Panel, simply add your own key to the views object. This is true for all view scopes.
New views require at least the Component and path properties:
Note: Routes are cascading, so unless explicitly given the exact property, they will match on URLs that simply start with the route's path. This is helpful when creating catch-all routes in your application. Alternatively, define your nested route before your parent route.
Custom Views are simply Custom Components rendered at the page-level. Custom Views can either replace existing views or add entirely new ones. The process is generally the same regardless of the type of view you are customizing.
To understand how to build Custom Views, first review the Building Custom Components guide. Once you have a Custom Component ready, you can use it as a Custom View.
Your Custom Views will be provided with the following props:
 Prop             
 Description                                                                                                                        
 initPageResult 
 An object containing req, payload, permissions, etc.                                                                         
 clientConfig 
 The Client Config object. More details.                                                 
 importMap 
 The import map object.                                                                                                             
 params 
 An object containing the Dynamic Route Parameters. 
 searchParams 
 An object containing the Search Parameters.  
 doc 
 The document being edited. Only available in Document Views. More details.                                     
 i18n 
 The i18n object.                                                                                          
 payload 
 The Payload class.                                                                                        
Note: Some views may receive additional props, such as Collection Views and Global Views. See the relevant section for more details.
Here is an example of a Custom View component:
Tip: For consistent layout and navigation, you may want to wrap your Custom View with one of the built-in Template.
Your Custom Root Views can optionally use one of the templates that Payload provides. The most common of these is the Default Template which provides the basic layout and navigation.
Here is an example of how to use the Default Template in your Custom View:
All Custom Views are public by default. It's up to you to secure your custom views. If your view requires a user to be logged in or to have certain access rights, you should handle that within your view component yourself.
Here is how you might secure a Custom View:
Root Views are the main views of the Admin Panel. These are views that are scoped directly under the /admin route, such as the Dashboard or Account views.
To swap out Root Views with your own, or to create entirely new ones, use the admin.components.views property at the root of your Payload Config:
For details on how to build Custom Views, including all available props, see Building Custom Views.
The following options are available:
 Property    
 Description                                                                                     
 account 
 The Account view is used to show the currently logged in user's Account page.                   
 dashboard 
 The main landing page of the Admin Panel.                                                       
 [key] 
 Any other key can be used to add a completely new Root View. More details. 
Collection Views are views that are scoped under the /collections route, such as the Collection List and Document Edit views.
To swap out Collection Views with your own, or to create entirely new ones, use the admin.components.views property of your Collection Config:
Reminder: The edit key is comprised of various nested views, known as Document Views, that relate to the same Collection Document. More details.
The following options are available:
 Property 
 Description                                                                                                                                     
 edit 
 The Edit View corresponds to a single Document for any given Collection and consists of various nested views. More details. 
 list 
 The List View is used to show a list of Documents for any given Collection. More details.                                         
 [key] 
 Any other key can be used to add a completely new Collection View. More details.                                           
For details on how to build Custom Views, including all available props, see Building Custom Views.
Global Views are views that are scoped under the /globals route, such as the Edit View.
To swap out Global Views with your own or create entirely new ones, use the admin.components.views property in your Global Config:
Reminder: The edit key is comprised of various nested views, known as Document Views, that relate to the same Global Document. More details.
The following options are available:
 Property 
 Description                                                                                                                             
 edit 
 The Edit View represents a single Document for any given Global and consists of various nested views. More details. 
 [key] 
 Any other key can be used to add a completely new Global View. More details.                                       
For details on how to build Custom Views, including all available props, see Building Custom Views.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/custom-components/document-views

Document Views consist of multiple, individual views that together represent any single Collection or Global Document. All Document Views and are scoped under the /collections/:collectionSlug/:id or the /globals/:globalSlug route, respectively.
There are a number of default Document Views, such as the Edit View and API View, but you can also create entirely new views as needed. All Document Views share a layout and can be given their own tab-based navigation, if desired.
To customize Document Views, use the admin.components.views.edit[key] property in your Collection Config or Global Config:
The following options are available:
 Property      
 Description                                                                                                                                                     
 root 
 The Root View overrides all other nested views and routes. No document controls or tabs are rendered when this key is set. More details.      
 default 
 The Default View is the primary view in which your document is edited. It is rendered within the "Edit" tab. More details.                       
 versions 
 The Versions View is used to navigate the version history of a single document. It is rendered within the "Versions" tab. More details. 
 version 
 The Version View is used to edit a single version of a document. It is rendered within the "Version" tab. More details.                 
 api 
 The API View is used to display the REST API JSON response for a given document. It is rendered within the "API" tab.                                           
 livePreview 
 The LivePreview view is used to display the Live Preview interface. It is rendered within the "Live Preview" tab. More details.     
 [key] 
 Any other key can be used to add a completely new Document View.                                                                                                
For details on how to build Custom Views, including all available props, see Building Custom Views.
The Document Root is mounted on the top-level route for a Document. Setting this property will completely take over the entire Document View layout, including the title, Document Tabs, and all other nested Document Views including the Edit View, API View, etc.
When setting a Document Root, you are responsible for rendering all necessary components and controls, as no document controls or tabs would be rendered. To replace only the Edit View precisely, use the edit.default key instead.
To override the Document Root, use the views.edit.root property in your Collection Config or Global Config:
The Edit View is where users interact with individual Collection and Global Documents. This is where they can view, edit, and save their content. the Edit View is keyed under the default property in the views.edit object.
For more information on customizing the Edit View, see the Edit View documentation.
Each Document View can be given a tab for navigation, if desired. Tabs are highly configurable, from as simple as changing the label to swapping out the entire component, they can be modified in any way.
To add or customize tabs in the Document View, use the views.edit.[key].tab property in your Collection Config or Global Config:
Note: This applies to both Collections and Globals.
The following options are available for tabs:
 Property    
 Description                                                                                                   
 label 
 The label to display in the tab.                                                                              
 href 
 The URL to navigate to when the tab is clicked. This is optional and defaults to the tab's path.            
 Component 
 The component to render in the tab. This can be a Server or Client component. More details 
If changing the label or href is not enough, you can also replace the entire tab component with your own custom component. This can be done by setting the tab.Component property to the path of your custom component.
Here is an example of how to scaffold a custom Document Tab:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/custom-components/edit-view

The Edit View is where users interact with individual Collection and Global Documents within the Admin Panel. The Edit View contains the actual form in which submits the data to the server. This is where they can view, edit, and save their content. It contains controls for saving, publishing, and previewing the document, all of which can be customized to a high degree.
The Edit View can be swapped out in its entirety for a Custom View, or it can be injected with a number of Custom Components to add additional functionality or presentational elements without replacing the entire view.
Note: The Edit View is one of many Document Views in the Payload Admin Panel. Each Document View is responsible for a different aspect of the interacting with a single Document.
To swap out the entire Edit View with a Custom View, use the views.edit.default property in your Collection Config or Global Config:
Here is an example of a custom Edit View:
For details on how to build Custom Views, including all available props, see Building Custom Views.
In addition to swapping out the entire Edit View with a Custom View, you can also override individual components. This allows you to customize specific parts of the Edit View without swapping out the entire view.
Important: Collection and Globals are keyed to a different property in the admin.components object have slightly different options. Be sure to use the correct key for the entity you are working with.
To override Edit View components for a Collection, use the admin.components.edit property in your Collection Config:
The following options are available:
 Path              
 Description                                                                            
 SaveButton 
 A button that saves the current document. More details.                 
 SaveDraftButton 
 A button that saves the current document as a draft. More details. 
 PublishButton 
 A button that publishes the current document. More details.          
 PreviewButton 
 A button that previews the current document. More details.           
 Description 
 A description of the Collection. More details.                         
 Upload 
 A file upload component. More details.                                      
To override Edit View components for Globals, use the admin.components.elements property in your Global Config:
The following options are available:
 Path              
 Description                                                                            
 SaveButton 
 A button that saves the current document. More details.                 
 SaveDraftButton 
 A button that saves the current document as a draft. More details. 
 PublishButton 
 A button that publishes the current document. More details.          
 PreviewButton 
 A button that previews the current document. More details.           
 Description 
 A description of the Global. More details.                             
The SaveButton property allows you to render a custom Save Button in the Edit View.
To add a SaveButton component, use the components.edit.SaveButton property in your Collection Config or components.elements.SaveButton in your Global Config:
Here's an example of a custom SaveButton component:
The SaveDraftButton property allows you to render a custom Save Draft Button in the Edit View.
To add a SaveDraftButton component, use the components.edit.SaveDraftButton property in your Collection Config or components.elements.SaveDraftButton in your Global Config:
Here's an example of a custom SaveDraftButton component:
The PublishButton property allows you to render a custom Publish Button in the Edit View.
To add a PublishButton component, use the components.edit.PublishButton property in your Collection Config or components.elements.PublishButton in your Global Config:
Here's an example of a custom PublishButton component:
The PreviewButton property allows you to render a custom Preview Button in the Edit View.
To add a PreviewButton component, use the components.edit.PreviewButton property in your Collection Config or components.elements.PreviewButton in your Global Config:
Here's an example of a custom PreviewButton component:
The Description property allows you to render a custom description of the Collection or Global in the Edit View.
To add a Description component, use the components.edit.Description property in your Collection Config or components.elements.Description in your Global Config:
Note: The Description component is shared between the Edit View and the List View.
Here's an example of a custom Description component:
The Upload property allows you to render a custom file upload component in the Edit View.
To add an Upload component, use the components.edit.Upload property in your Collection Config:
Note: The Upload component is only available for Collections.
Here's an example of a custom Upload component:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/custom-components/list-view

The List View is where users interact with a list of Collection Documents within the Admin Panel. This is where they can view, sort, filter, and paginate their documents to find exactly what they're looking for. This is also where users can perform bulk operations on multiple documents at once, such as deleting, editing, or publishing many.
The List View can be swapped out in its entirety for a Custom View, or it can be injected with a number of Custom Components to add additional functionality or presentational elements without replacing the entire view.
Note: Only Collections have a List View. Globals do not have a List View as they are single documents.
To swap out the entire List View with a Custom View, use the admin.components.views.list property in your Payload Config:
Here is an example of a custom List View:
For details on how to build Custom Views, including all available props, see Building Custom Views.
In addition to swapping out the entire List View with a Custom View, you can also override individual components. This allows you to customize specific parts of the List View without swapping out the entire view for your own.
To override List View components for a Collection, use the admin.components property in your Collection Config:
The following options are available:
 Path              
 Description                                                                                                               
 beforeList 
 An array of custom components to inject before the list of documents in the List View. More details.       
 beforeListTable 
 An array of custom components to inject before the table of documents in the List View. More details. 
 afterList 
 An array of custom components to inject after the list of documents in the List View. More details.         
 afterListTable 
 An array of custom components to inject after the table of documents in the List View. More details.   
 Description 
 A component to render a description of the Collection. More details.                                      
The beforeList property allows you to inject custom components before the list of documents in the List View.
To add beforeList components, use the components.beforeList property in your Collection Config:
Here's an example of a custom beforeList component:
The beforeListTable property allows you to inject custom components before the table of documents in the List View.
To add beforeListTable components, use the components.beforeListTable property in your Collection Config:
Here's an example of a custom beforeListTable component:
The afterList property allows you to inject custom components after the list of documents in the List View.
To add afterList components, use the components.afterList property in your Collection Config:
Here's an example of a custom afterList component:
The afterListTable property allows you to inject custom components after the table of documents in the List View.
To add afterListTable components, use the components.afterListTable property in your Collection Config:
Here's an example of a custom afterListTable component:
The Description property allows you to render a custom description of the Collection in the List View.
To add a Description component, use the components.Description property in your Collection Config:
Note: The Description component is shared between the List View and the Edit View.
Here's an example of a custom Description component:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/authentication/overview

Authentication is a critical part of any application. Payload provides a secure, portable way to manage user accounts out of the box. Payload Authentication is designed to be used in both the Admin Panel, all well as your own external applications, completely eliminating the need for paid, third-party platforms and services.
Here are some common use cases of Authentication in your own applications:
When Authentication is enabled on a Collection, Payload injects all necessary functionality to support the entire user flow. This includes all auth-related operations like account creation, logging in and out, and resetting passwords, all auth-related emails like email verification and password reset, as well as any necessary UI to manage users from the Admin Panel.
To enable Authentication on a Collection, use the auth property in the Collection Config:
Admin Panel screenshot depicting an Admins Collection with Auth enabled
Any Collection can opt-in to supporting Authentication. Once enabled, each Document that is created within the Collection can be thought of as a "user". This enables a complete authentication workflow on your Collection, such as logging in and out, resetting their password, and more.
Note: By default, Payload provides an auth-enabled User Collection which is used to access the Admin Panel. More details.
To enable Authentication on a Collection, use the auth property in the Collection Config:
Tip: For default auth behavior, set auth: true. This is a good starting point for most applications.
Note: Auth-enabled Collections with be automatically injected with the hash, salt, and email fields. More details.
The following options are available:
 Option                         
 Description                                                                                                                                                                                                                 
 cookies 
 Set cookie options, including secure, sameSite, and domain. For advanced users.                                                                                                                                       
 depth 
 How many levels deep a user document should be populated when creating the JWT and binding the user to the req. Defaults to 0 and should only be modified if absolutely necessary, as this will affect performance. 
 disableLocalStrategy 
 Advanced - disable Payload's built-in local auth strategy. Only use this property if you have replaced Payload's auth mechanisms with your own.                                                                             
 forgotPassword 
 Customize the way that the forgotPassword operation functions. More details.                                                                                                                   
 lockTime 
 Set the time (in milliseconds) that a user should be locked out if they fail authentication more times than maxLoginAttempts allows for.                                                                                  
 loginWithUsername 
 Ability to allow users to login with username/password. More 
 maxLoginAttempts 
 Only allow a user to attempt logging in X amount of times. Automatically locks out a user from authenticating if this limit is passed. Set to 0 to disable.                                                               
 removeTokenFromResponses 
 Set to true if you want to remove the token from the returned authentication API responses such as login or refresh.                                                                                                        
 strategies 
 Advanced - an array of custom authentication strategies to extend this collection's authentication with. More details.                                                                               
 tokenExpiration 
 How long (in seconds) to keep the user logged in. JWTs and HTTP-only cookies will both expire at the same time.                                                                                                             
 useAPIKey 
 Payload Authentication provides for API keys to be set on each user within an Authentication-enabled Collection. More details.                                                                                
 verify 
 Set to true or pass an object with verification options to require users to verify by email before they are allowed to log into your app. More details.                                     
You can allow users to login with their username instead of their email address by setting the loginWithUsername property to true.
Example:
Or, you can pass an object with additional options:
allowEmailLogin
If set to true, users can log in with either their username or email address. If set to false, users can only log in with their username.
requireEmail
If set to true, an email address is required when creating a new user. If set to false, email is not required upon creation.
For testing and demo purposes you may want to skip forcing the user to login in order to access your application. Typically, all users should be required to login, however, you can speed up local development time by enabling auto-login.
To enable auto-login, set the autoLogin property in the Payload Config:
Warning: The recommended way to use this feature is behind an Environment Variable. This will ensure it is disabled in production.
The following options are available:
 Option            
 Description                                                                                                     
 username 
 The username of the user to login as                                                                            
 email 
 The email address of the user to login as                                                                       
 password 
 The password of the user to login as. This is only needed if prefillOnly is set to true                       
 prefillOnly 
 If set to true, the login credentials will be prefilled but the user will still need to click the login button. 
All auth-related operations are available via Payload's REST, Local, and GraphQL APIs. These operations are automatically added to your Collection when you enable Authentication. More details.
Out of the box Payload ships with a three powerful Authentication strategies:
Each of these strategies can work together or independently. You can also create your own custom strategies to fit your specific needs. More details.
HTTP-only cookies are a highly secure method of storing identifiable data on a user's device so that Payload can automatically recognize a returning user until their cookie expires. They are totally protected from common XSS attacks and cannot be read by JavaScript in the browser, unlike JWT's. More details.
JWT (JSON Web Tokens) can also be utilized to perform authentication. Tokens are generated on login, refresh and me operations and can be attached to future requests to authenticate users. More details.
API Keys can be enabled on auth collections. These are particularly useful when you want to authenticate against Payload from a third party service. More details.
There are cases where these may not be enough for your application. Payload is extendable by design so you can wire up your own strategy when you need to. More details.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/authentication/operations

Enabling Authentication on a Collection automatically exposes additional auth-based operations in the Local API, REST API, and GraphQL API.
The Access operation returns what a logged in user can and can't do with the collections and globals that are registered via your config. This data can be immensely helpful if your app needs to show and hide certain features based on Access Control, just as the Admin Panel does.
REST API endpoint:
GET http://localhost:3000/api/access
Example response:
Example GraphQL Query:
Document access can also be queried on a collection/global basis. Access on a global can queried like http://localhost:3000/api/global-slug/access, Collection document access can be queried like http://localhost:3000/api/collection-slug/access/:id.
Returns either a logged in user with token or null when there is no logged in user.
REST API endpoint:
GET http://localhost:3000/api/[collection-slug]/me
Example response:
Example GraphQL Query:
Accepts an email and password. On success, it will return the logged in user as well as a token that can be used to authenticate. In the GraphQL and REST APIs, this operation also automatically sets an HTTP-only cookie including the user's token. If you pass a res to the Local API operation, Payload will set a cookie there as well.
Example REST API login:
Example GraphQL Mutation:
Example Local API login:
As Payload sets HTTP-only cookies, logging out cannot be done by just removing a cookie in JavaScript, as HTTP-only cookies are inaccessible by JS within the browser. So, Payload exposes a logout operation to delete the token in a safe way.
Example REST API logout:
Example GraphQL Mutation:
Allows for "refreshing" JWTs. If your user has a token that is about to expire, but the user is still active and using the app, you might want to use the refresh operation to receive a new token by executing this operation via the authenticated user.
This operation requires a non-expired token to send back a new one. If the user's token has already expired, you will need to allow them to log in again to retrieve a new token.
If successful, this operation will automatically renew the user's HTTP-only cookie and will send back the updated token in JSON.
Example REST API token refresh:
Example GraphQL Mutation:
If your collection supports email verification, the Verify operation will be exposed which accepts a verification token and sets the user's _verified property to true, thereby allowing the user to authenticate with the Payload API.
Example REST API user verification:
Example GraphQL Mutation:
Example Local API verification:
Note: the token you need to pass to the verifyEmail function is unique to verification and is not the same as the token that you can retrieve from the forgotPassword operation. It can be found on the user document, as a hidden _verificationToken field. If you'd like to retrieve this token, you can use the Local API's find or findByID methods, setting showHiddenFields: true.
Note: if you do not have a config.serverURL set, Payload will attempt to create one for you if the user was created via REST or GraphQL by looking at the incoming req. But this is not supported if you are creating the user via the Local API's payload.create() method. If this applies to you, and you do not have a serverURL set, you may want to override your verify.generateEmailHTML function to provide a full URL to link the user to a proper verification page.
If a user locks themselves out and you wish to deliberately unlock them, you can utilize the Unlock operation. The Admin Panel features an Unlock control automatically for all collections that feature max login attempts, but you can programmatically unlock users as well by using the Unlock operation.
To restrict who is allowed to unlock users, you can utilize the unlock access control function.
Example REST API unlock:
Example GraphQL Mutation:
Example Local API unlock:
Payload comes with built-in forgot password functionality. Submitting an email address to the Forgot Password operation will generate an email and send it to the respective email address with a link to reset their password.
The link to reset the user's password contains a token which is what allows the user to securely reset their password.
By default, the Forgot Password operations send users to the Admin Panel to reset their password, but you can customize the generated email to send users to the frontend of your app instead by overriding the email HTML.
Example REST API Forgot Password:
Example GraphQL Mutation:
Example Local API forgot password:
Note: if you do not have a config.serverURL set, Payload will attempt to create one for you if the forgot-password operation was triggered via REST or GraphQL by looking at the incoming req. But this is not supported if you are calling payload.forgotPassword() via the Local API. If you do not have a serverURL set, you may want to override your auth.forgotPassword.generateEmailHTML function to provide a full URL to link the user to a proper reset-password page.
 Tip:
You can stop the reset-password email from being sent via using the Local API. This is helpful if you need to create user accounts programmatically, but not set their password for them. This effectively generates a reset password token which you can then use to send to a page you create, allowing a user to "complete" their account by setting their password. In the background, you'd use the token to "reset" their password.
After a user has "forgotten" their password and a token is generated, that token can be used to send to the reset password operation along with a new password which will allow the user to reset their password securely.
Example REST API Reset Password:
Example GraphQL Mutation:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/authentication/email

Authentication ties directly into the Email functionality that Payload provides. This allows you to send emails to users for verification, password resets, and more. While Payload provides default email templates for these actions, you can customize them to fit your brand.
Email Verification forces users to prove they have access to the email address they can authenticate. This will help to reduce spam accounts and ensure that users are who they say they are.
To enable Email Verification, use the auth.verify property on your Collection Config:
Tip: Verification emails are fully customizable. More details.
The following options are available:
 Option                     
 Description                                                                                                                                           
 generateEmailHTML 
 Allows for overriding the HTML within emails that are sent to users indicating how to validate their account. More details.     
 generateEmailSubject 
 Allows for overriding the subject of the email that is sent to users indicating how to validate their account. More details. 
Function that accepts one argument, containing { req, token, user }, that allows for overriding the HTML within emails that are sent to users indicating how to validate their account. The function should return a string that supports HTML, which can optionally be a full HTML email.
Important: If you specify a different URL to send your users to for email verification, such as a page on the frontend of your app or similar, you need to handle making the call to the Payload REST or GraphQL verification operation yourself on your frontend, using the token that was provided for you. Above, it was passed via query parameter.
Similarly to the above generateEmailHTML, you can also customize the subject of the email. The function argument are the same but you can only return a string - not HTML.
You can customize how the Forgot Password workflow operates with the following options on the auth.forgotPassword property:
The following options are available:
 Option                     
 Description                                                                                                                                     
 expiration 
 Configure how long password reset tokens remain valid, specified in milliseconds.                                                               
 generateEmailHTML 
 Allows for overriding the HTML within emails that are sent to users attempting to reset their password. More details.     
 generateEmailSubject 
 Allows for overriding the subject of the email that is sent to users attempting to reset their password. More details. 
This function allows for overriding the HTML within emails that are sent to users attempting to reset their password. The function should return a string that supports HTML, which can be a full HTML email.
Important: If you specify a different URL to send your users to for resetting their password, such as a page on the frontend of your app or similar, you need to handle making the call to the Payload REST or GraphQL reset-password operation yourself on your frontend, using the token that was provided for you. Above, it was passed via query parameter.
Tip: HTML templating can be used to create custom email templates, inline CSS automatically, and more. You can make a reusable function that standardizes all email sent from Payload, which makes sending custom emails more DRY. Payload doesn't ship with an HTML templating engine, so you are free to choose your own.
The following arguments are passed to the generateEmailHTML function:
 Argument 
 Description                                                       
 req 
 The request object.                                               
 token 
 The token that is generated for the user to reset their password. 
 user 
 The user document that is attempting to reset their password.     
Similarly to the above generateEmailHTML, you can also customize the subject of the email. The function argument are the same but you can only return a string - not HTML.
The following arguments are passed to the generateEmailSubject function:
 Argument 
 Description                                                   
 req 
 The request object.                                           
 user 
 The user document that is attempting to reset their password. 
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/authentication/jwt

Payload offers the ability to Authenticate via JSON Web Tokens (JWT). These can be read from the responses of login, logout, refresh, and me auth operations.
Tip: You can access the logged-in user from within Access Control and Hooks through the req.user argument. More details.
In addition to authenticating via an HTTP-only cookie, you can also identify users via the Authorization header on an HTTP request.
Example:
In some cases you may want to prevent the token from being returned from the auth operations. You can do that by setting removeTokenFromResponse to true like so:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/authentication/cookies

Payload offers the ability to Authenticate via HTTP-only cookies. These can be read from the responses of login, logout, refresh, and me auth operations.
Tip: You can access the logged-in user from within Access Control and Hooks through the req.user argument. More details.
Modern browsers automatically include http-only cookies when making requests directly to URLs—meaning that if you are running your API on https://example.com, and you have logged in and visit https://example.com/test-page, your browser will automatically include the Payload authentication cookie for you.
However, if you use fetch or similar APIs to retrieve Payload resources from its REST or GraphQL API, you must specify to include credentials (cookies).
Fetch example, including credentials:
For more about including cookies in requests from your app to your Payload API, read the MDN docs.
Tip: To make sure you have a Payload cookie set properly in your browser after logging in, you can use the browsers Developer Tools > Application > Cookies > [your-domain-here]. The Developer tools will still show HTTP-only cookies.
CSRF (cross-site request forgery) attacks are common and dangerous. By using an HTTP-only cookie, Payload removes many XSS vulnerabilities, however, CSRF attacks can still be possible.
For example, let's say you have a popular app https://payload-finances.com that allows users to manage finances, send and receive money. As Payload is using HTTP-only cookies, that means that browsers automatically will include cookies when sending requests to your domain - no matter what page created the request.
So, if a user of https://payload-finances.com is logged in and is browsing around on the internet, they might stumble onto a page with malicious intent. Let's look at an example:
In this scenario, if your cookie was still valid, malicious-intent.com would be able to make requests like the one above on your behalf. This is a CSRF attack.
Define domains that your trust and are willing to accept Payload HTTP-only cookie based requests from. Use the csrf option on the base Payload Config to do this:
If your frontend is on a different domain than your Payload API then you will not be able to use HTTP-only cookies for authentication by default as they will be considered third-party cookies by the browser. There are a few strategies to get around this:
Cookies can cross subdomains without being considered third party cookies, for example if your API is at api.example.com then you can authenticate from example.com.
If option 1 isn't possible, then you can get around this limitation by configuring your cookies on your authentication collection to achieve the following setup:
Configuration example:
If you're configuring cors in your Payload config, you won't be able to use a wildcard anymore, you'll need to specify the list of allowed domains.
Good to know: Setting up secure: true will not work if you're developing on http://localhost or any non-https domain. For local development you should conditionally set this to false based on the environment.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/authentication/api-keys

To integrate with third-party APIs or services, you might need the ability to generate API keys that can be used to identify as a certain user within Payload. API keys are generated on a user-by-user basis, similar to email and passwords, and are meant to represent a single user.
For example, if you have a third-party service or external app that needs to be able to perform protected actions against Payload, first you need to create a user within Payload, i.e. dev@thirdparty.com. From your external application you will need to authenticate with that user, you have two options:
 Tip:
This is particularly useful as you can create a "user" that reflects an integration with a specific external service and assign a "role" or specific access only needed by that service/integration.
Technically, both of these options will work for third-party integrations but the second option with API key is simpler, because it reduces the amount of work that your integrations need to do to be authenticated properly.
To enable API keys on a collection, set the useAPIKey auth option to true. From there, a new interface will appear in the Admin Panel for each document within the collection that allows you to generate an API key for each user in the Collection.
User API keys are encrypted within the database, meaning that if your database is compromised, your API keys will not be.
 Important: If you change your PAYLOAD_SECRET, you will need to regenerate your API keys.
The secret key is used to encrypt the API keys, so if you change the secret, existing API keys will no longer be valid.
To authenticate REST or GraphQL API requests using an API key, set the Authorization header. The header is case-sensitive and needs the slug of the auth.useAPIKey enabled collection, then " API-Key ", followed by the apiKey that has been assigned. Payload's built-in middleware will then assign the user document to req.user and handle requests with the proper Access Control. By doing this, Payload recognizes the request being made as a request by the user associated with that API key.
For example, using Fetch:
Payload ensures that the same, uniform Access Control is used across all authentication strategies. This enables you to utilize your existing Access Control configurations with both API keys and the standard email/password authentication. This consistency can aid in maintaining granular control over your API keys.
If you want to use API keys as the only authentication method for a collection, you can disable the default local strategy by setting disableLocalStrategy to true on the collection's auth property. This will disable the ability to authenticate with email and password, and will only allow for authentication via API key.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/authentication/custom-strategies

This is an advanced feature, so only attempt this if you are an experienced developer. Otherwise, just let Payload's built-in authentication handle user auth for you.
At the core, a strategy is a way to authenticate a user making a request. As of 3.0 we moved away from Passport in favor of pulling back the curtain and putting you in full control.
A strategy is made up of the following:
 Parameter             
 Description                                                               
 name *         
 The name of your strategy                                                 
 authenticate * 
 A function that takes in the parameters below and returns a user or null. 
The authenticate function is passed the following arguments:
 Argument         
 Description                                                                                       
 headers * 
 The headers on the incoming request. Useful for retrieving identifiable information on a request. 
 payload * 
 The Payload class. Useful for authenticating the identifiable information against Payload.        
 isGraphQL 
 Whether or not the request was made from a GraphQL endpoint. Default is false.                  
At its core a strategy simply takes information from the incoming request and returns a user. This is exactly how Payload's built-in strategies function.
Your authenticate method should return an object containing a Payload user document and any optional headers that you'd like Payload to set for you when we return a response.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/authentication/token-data

During the lifecycle of a request you will be able to access the data you have configured to be stored in the JWT by accessing req.user. The user object is automatically appended to the request for you.
You can specify what data gets encoded to the Cookie/JWT-Token by setting saveToJWT property on fields within your auth collection.
 Tip:
If you wish to use a different key other than the field name, you can define saveToJWT as a string.
This is especially helpful when writing Hooks and Access Control that depend on user defined fields.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/rich-text/overview

This documentation is about our new editor, based on Lexical (Meta's rich text editor). The previous default editor was based on Slate and is still supported. You can read its documentation, or the optional migration guide to migrate from Slate to Lexical (recommended).
The editor is the most important property of the rich text field.
As a key part of Payload, we are proud to offer you the best editing experience you can imagine. With healthy defaults out of the box, but also with the flexibility to customize every detail: from the “/” menu and toolbars (whether inline or fixed) to inserting any component or subfield you can imagine.
To use the rich text editor, first you need to install it:
Once you have it installed, you can pass it to your top-level Payload Config as follows:
You can also override Lexical settings on a field-by-field basis as follows:
Lexical has been designed with extensibility in mind. Whether you're aiming to introduce new functionalities or tweak the existing ones, Lexical makes it seamless for you to bring those changes to life.
At the heart of Lexical's customization potential are "features". While Lexical ships with a set of default features we believe are essential for most use cases, the true power lies in your ability to redefine, expand, or prune these as needed.
If you remove all the default features, you're left with a blank editor. You can then add in only the features you need, or you can build your own custom features from scratch.
To weave in your custom features, utilize the features prop when initializing the Lexical Editor. Here's a basic example of how this is done:
features can be both an array of features, or a function returning an array of features. The function provides the following props:
 Prop                  
 Description                                                                                                                                                                                                                                            
 defaultFeatures 
 This opinionated array contains all "recommended" default features. You can see which features are included in the default features in the table below.                                                                                                
 rootFeatures 
 This array contains all features that are enabled in the root richText editor (the one defined in the payload.config.ts). If this field is the root richText editor, or if the root richText editor is not a lexical editor, this array will be empty. 
Here's an overview of all the included features:
 Feature Name                    
 Included by default 
 Description                                                                                                                                                                         
 BoldFeature 
 Yes                 
 Handles the bold text format                                                                                                                                                        
 ItalicFeature 
 Yes                 
 Handles the italic text format                                                                                                                                                      
 UnderlineFeature 
 Yes                 
 Handles the underline text format                                                                                                                                                   
 StrikethroughFeature 
 Yes                 
 Handles the strikethrough text format                                                                                                                                               
 SubscriptFeature 
 Yes                 
 Handles the subscript text format                                                                                                                                                   
 SuperscriptFeature 
 Yes                 
 Handles the superscript text format                                                                                                                                                 
 InlineCodeFeature 
 Yes                 
 Handles the inline-code text format                                                                                                                                                 
 ParagraphFeature 
 Yes                 
 Handles paragraphs. Since they are already a key feature of lexical itself, this Feature mainly handles the Slash and Add-Block menu entries for paragraphs                         
 HeadingFeature 
 Yes                 
 Adds Heading Nodes (by default, H1 - H6, but that can be customized)                                                                                                                
 AlignFeature 
 Yes                 
 Allows you to align text left, centered and right                                                                                                                                   
 IndentFeature 
 Yes                 
 Allows you to indent text with the tab key                                                                                                                                          
 UnorderedListFeature 
 Yes                 
 Adds unordered lists (ul)                                                                                                                                                           
 OrderedListFeature 
 Yes                 
 Adds ordered lists (ol)                                                                                                                                                             
 ChecklistFeature 
 Yes                 
 Adds checklists                                                                                                                                                                     
 LinkFeature 
 Yes                 
 Allows you to create internal and external links                                                                                                                                    
 RelationshipFeature 
 Yes                 
 Allows you to create block-level (not inline) relationships to other documents                                                                                                      
 BlockquoteFeature 
 Yes                 
 Allows you to create block-level quotes                                                                                                                                             
 UploadFeature 
 Yes                 
 Allows you to create block-level upload nodes - this supports all kinds of uploads, not just images                                                                                 
 HorizontalRuleFeature 
 Yes                 
 Horizontal rules / separators. Basically displays an <hr> element                                                                                                                 
 InlineToolbarFeature 
 Yes                 
 The inline toolbar is the floating toolbar which appears when you select text. This toolbar only contains actions relevant for selected text                                        
 FixedToolbarFeature 
 No                  
 This classic toolbar is pinned to the top and always visible. Both inline and fixed toolbars can be enabled at the same time.                                                       
 BlocksFeature 
 No                  
 Allows you to use Payload's Blocks Field directly inside your editor. In the feature props, you can specify the allowed blocks - just like in the Blocks field. 
 TreeViewFeature 
 No                  
 Adds a debug box under the editor, which allows you to see the current editor state live, the dom, as well as time travel. Very useful for debugging                                
 EXPERIMENTAL_TableFeature 
 No                  
 Adds support for tables. This feature may be removed or receive breaking changes in the future - even within a stable lexical release, without needing a major release.             
Notice how even the toolbars are features? That's how extensible our lexical editor is - you could theoretically create your own toolbar if you wanted to!
You can find more information about creating your own feature in our building custom feature docs.
Every single piece of saved data is 100% fully typed within lexical. It provides a type for every single node, which can be imported from @payloadcms/richtext-lexical - each type is prefixed with Serialized, e.g., SerializedUploadNode.
To fully type the entire editor JSON, you can use our TypedEditorState helper type, which accepts a union of all possible node types as a generic. We don't provide a type that already contains all possible node types because they depend on which features you have enabled in your editor. Here is an example:
Alternatively, you can use the DefaultTypedEditorState type, which includes all types for all nodes included in the defaultFeatures:
Just like TypedEditorState, the DefaultTypedEditorState also accepts an optional node type union as a generic. Here, this would add the specified node types to the default ones. Example:
This is a type-safe representation of the editor state. If you look at the auto suggestions of a node's type property, you will see all the possible node types you can use.
Make sure to only use types exported from @payloadcms/richtext-lexical, not from the lexical core packages. We only have control over the types we export and can make sure they're correct, even though the lexical core may export types with identical names.
Lexical does not generate accurate type definitions for your richText fields for you yet - this will be improved in the future. Currently, it only outputs the rough shape of the editor JSON, which you can enhance using type assertions.
The Rich Text Field editor configuration has an admin property with the following options:
 Property                       
 Description                                                                              
 placeholder 
 Set this property to define a placeholder string for the field.                          
 hideGutter 
 Set this property to true to hide this field's gutter within the Admin Panel.          
 hideInsertParagraphAtEnd 
 Set this property to true to hide the "+" button that appears at the end of the editor 
You can disable the gutter (the vertical line padding between the editor and the left edge of the screen) by setting the hideGutter prop to true:
You can customize the placeholder (the text that appears in the editor when it's empty) by setting the placeholder prop:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/rich-text/converters

Richtext fields save data in JSON - this is great for storage and flexibility and allows you to easily to convert it to other formats:
Some converters require access to the Lexical editor config, which defines available features and behaviors. Payload provides multiple ways to obtain the editor config through the editorConfigFactory from @payloadcms/richtext-lexical.
First, import the necessary utilities:
If you require the default editor config:
When a lexical field config is available, you can extract the editor config directly:
You can create a custom editor configuration by specifying additional features:
If you've created a global or reusable Lexical editor instance, you can access its configuration. This method is typically less efficient and not recommended:
For better efficiency, consider extracting the features into a separate variable and using fromFeatures instead of this method.
If you have access to the sanitized collection config, you can access the lexical sanitized editor config, as every lexical richText field returns it. Here is an example how you can retrieve it from another field's afterRead hook:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/rich-text/converting-jsx

To convert richtext to JSX, import the RichText component from @payloadcms/richtext-lexical/react and pass the richtext content to it:
The RichText component includes built-in converters for common Lexical nodes. You can add or override converters via the converters prop for custom blocks, custom nodes, or any modifications you need. See the website template for a working example.
When fetching data, ensure your depth setting is high enough to fully populate Lexical nodes such as uploads. The JSX converter requires fully populated data to work correctly.
By default, Payload doesn't know how to convert internal links to JSX, as it doesn't know what the corresponding URL of the internal link is. You'll notice that you get a "found internal link, but internalDocToHref is not provided" error in the console when you try to render content with internal links.
To fix this, you need to pass the internalDocToHref prop to LinkJSXConverter. This prop is a function that receives the link node and returns the URL of the document.
If your rich text includes custom Blocks or Inline Blocks, you must supply custom converters that match each block's slug. This converter is not included by default, as Payload doesn't know how to render your custom blocks.
For example:
You can override any of the default JSX converters by passing passing your custom converter, keyed to the node type, to the converters prop / the converters function.
Example - overriding the upload node converter to use next/image:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/rich-text/converting-html

There are two main approaches to convert your Lexical-based rich text to HTML:
To convert JSON to HTML on-demand, use the convertLexicalToHTML function from @payloadcms/richtext-lexical/html. Here's an example of how to use it in a React component in your frontend:
If your rich text includes Lexical blocks, you need to provide a way to convert them to HTML. For example:
To automatically generate HTML from the saved richText field in your Collection, use the lexicalHTMLField() helper. This approach converts the JSON to HTML using an afterRead hook. For instance:
By default, convertLexicalToHTML expects fully populated data (e.g. uploads, links, etc.). If you need to dynamically fetch and populate those nodes, use the async variant, convertLexicalToHTMLAsync, from @payloadcms/richtext-lexical/html-async. You must provide a populate function:
Using the REST populate function will send a separate request for each node. If you need to populate a large number of nodes, this may be slow. For improved performance on the server, you can use the getPayloadPopulateFn function:
If you need to convert raw HTML into a Lexical editor state, use convertHTMLToLexical from @payloadcms/richtext-lexical, along with the editorConfigFactory to retrieve the editor config:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/rich-text/converting-markdown

If you have access to the Payload Config and the lexical editor config, you can convert the lexical editor state to Markdown with the following:
If you have access to the Payload Config and the lexical editor config, you can convert Markdown to the lexical editor state with the following:
Payload supports serializing and deserializing MDX content. While Markdown converters are stored on the features, MDX converters are stored on the blocks that you pass to the BlocksFeature.
Here is an example of a Banner block.
This block:
The conversion is done using the jsx property of the block. The export function is called when converting from lexical to MDX, and the import function is called when converting from MDX to lexical.
The export function takes the block field data and the lexicalToMarkdown function as arguments. It returns the following object:
 Property   
 Type   
 Description                                                        
 children 
 string 
 This will be in between the opening and closing tags of the block. 
 props 
 object 
 This will be in the opening tag of the block.                      
The import function provides data extracted from the MDX. It takes the following arguments:
 Argument   
 Type   
 Description                                                                          
 children 
 string 
 This will be the text between the opening and closing tags of the block.             
 props 
 object 
 These are the props passed to the block, parsed from the opening tag into an object. 
The returning object is equal to the block field data.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/rich-text/converting-plaintext

Here's how you can convert richtext data to plaintext using @payloadcms/richtext-lexical/plaintext.
The convertLexicalToPlaintext functions accepts a converters object that allows you to customize how specific nodes are converted to plaintext.
Unlike other converters, there are no default converters for plaintext.
If a node does not have a converter defined, the following heuristics are used to convert it to plaintext:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/rich-text/custom-features

Before you begin building custom features for Lexical, it is crucial to familiarize yourself with the Lexical docs, particularly the "Concepts" section. This foundation is necessary for understanding Lexical's core principles, such as nodes, editor state, and commands.
Lexical features are designed to be modular, meaning each piece of functionality is encapsulated within just two specific interfaces: one for server-side code and one for client-side code.
By convention, these are named feature.server.ts for server-side functionality and feature.client.ts for client-side functionality. The primary functionality is housed within feature.server.ts, which users will import into their projects. The client-side feature, although defined separately, is integrated and rendered server-side through the server feature.
That way, we still maintain a clear boundary between server and client code, while also centralizing the code needed for a feature in basically one place. This approach is beneficial for managing all the bits and pieces which make up your feature as a whole, such as toolbar entries, buttons, or new nodes, allowing each feature to be neatly contained and managed independently.
 Important: Do not import directly from core lexical packages - this may break in minor Payload version bumps.
Instead, import the re-exported versions from @payloadcms/richtext-lexical. For example, change import { $insertNodeToNearestRoot } from '@lexical/utils' to import { $insertNodeToNearestRoot } from '@payloadcms/richtext-lexical/lexical/utils'
Before you start building a custom feature, consider whether you can achieve your desired functionality using the existing BlocksFeature. The BlocksFeature is a powerful feature that allows you to create custom blocks with a variety of options, including custom React components, markdown converters, and more. If you can achieve your desired functionality using the BlocksFeature, it is recommended to use it instead of building a custom feature.
Using the BlocksFeature, you can add both inline blocks (= can be inserted into a paragraph, in between text) and block blocks (= take up the whole line) to the editor. If you simply want to bring custom react components into the editor, this is the way to go.
This example demonstrates how to create a custom code field block with a language picker using the BlocksFeature. First, make sure to explicitly install @payloadcms/ui in your project.
Field Config:
CodeComponent.tsx:
Custom Blocks are not enough? To start building a custom feature, you should start with the server feature, which is the entry-point.
Example myFeature/feature.server.ts:
createServerFeature is a helper function which lets you create new features without boilerplate code.
Now, the feature is ready to be used in the editor:
By default, this server feature does nothing - you haven't added any functionality yet. Depending on what you want your feature to do, the ServerFeature type exposes various properties you can set to inject custom functionality into the lexical editor.
Each feature can register their own translations, which are automatically scoped to the feature key:
This allows you to add i18n translations scoped to your feature. This specific example translation will be available under lexical:myFeature:label - myFeature being your feature key.
The Server Feature, just like the Client Feature, allows you to add markdown transformers. Markdown transformers on the server are used when converting the editor from or to markdown.
In this example, the node will be outputted as +++ in Markdown, and the markdown +++ will be converted to a MyNode node in the editor.
While nodes added to the server feature do not control how the node is rendered in the editor, they control other aspects of the node:
The createNode helper function is used to create nodes with proper typing. It is recommended to use this function to create nodes.
While nodes in the client feature are added by themselves to the nodes array, nodes in the server feature can be added together with the following sibling options:
 Option                          
 Description                                                                                                                                                                                                                                                                                                                                                                                                                                                   
 getSubFields 
 If a node includes sub-fields (e.g. block and link nodes), passing the subFields schema here will make Payload automatically populate & run hooks for them.                                                                                                                                                                                                                                                                                                   
 getSubFieldsData 
 If a node includes sub-fields, the sub-fields data needs to be returned here, alongside getSubFields which returns their schema.                                                                                                                                                                                                                                                                                                                            
 graphQLPopulationPromises 
 Allows you to run population logic when a node's data was requested from GraphQL. While getSubFields and getSubFieldsData automatically handle populating sub-fields (since they run hooks on them), those are only populated in the Rest API. This is because the Rest API hooks do not have access to the 'depth' property provided by GraphQL. In order for them to be populated correctly in GraphQL, the population logic needs to be provided here. 
 node 
 The actual lexical node needs to be provided here. This also supports lexical node replacements.                                                                                                                                                                                                                                                                                                        
 validations 
 This allows you to provide node validations, which are run when your document is being validated, alongside other Payload fields. You can use it to throw a validation error for a specific node in case its data is incorrect.                                                                                                                                                                                                                               
 converters 
 Allows you to define how a node can be serialized into different formats. Currently, only supports HTML. Markdown converters are defined in markdownTransformers and not here.                                                                                                                                                                                                                                                                              
 hooks 
 Just like Payload fields, you can provide hooks which are run for this specific node. These are called Node Hooks.                                                                                                                                                                                                                                                                                                                                            
Server features can also accept a function as the feature property (useful for sanitizing props, as mentioned below). This function will be called when the feature is loaded during the Payload sanitization process:
"Loading" here means the process of calling this feature function. By default, features are called in the order in which they are added to the editor. However, sometimes you might want to load a feature after another feature has been loaded, or require a different feature to be loaded, throwing an error if this is not the case.
Within lexical, one example where this is done are our list features. Both UnorderedListFeature and OrderedListFeature register the same ListItem node. Within UnorderedListFeature we register it normally, but within OrderedListFeature we want to only register the ListItem node if the UnorderedListFeature is not present - otherwise, we would have two features registering the same node.
Here is how we do it:
featureProviderMap will always be available and contain all the features, even yet-to-be-loaded ones, so we can check if a feature is loaded by checking if its key present in the map.
If you wanted to make sure a feature is loaded before another feature, you can use the dependenciesPriority property:
 Option                     
 Description                                                                                                                                                                                               
 dependenciesSoft 
 Keys of soft-dependencies needed for this feature. These are optional. Payload will attempt to load them before this feature, but doesn't throw an error if that's not possible.                          
 dependencies 
 Keys of dependencies needed for this feature. These dependencies do not have to be loaded first, but they have to exist, otherwise an error will be thrown.                                               
 dependenciesPriority 
 Keys of priority dependencies needed for this feature. These dependencies have to be loaded first AND have to exist, otherwise an error will be thrown. They will be available in the feature property. 
Most of the functionality which the user actually sees and interacts with, like toolbar items and React components for nodes, resides on the client-side.
To set up your client-side feature, follow these three steps:
Example myFeature/feature.client.ts:
Explore the APIs available through ClientFeature to add the specific functionality you need. Remember, do not import directly from '@payloadcms/richtext-lexical' when working on the client-side, as it will cause errors with webpack or turbopack. Instead, use '@payloadcms/richtext-lexical/client' for all client-side imports. Type-imports are excluded from this rule and can always be imported.
Inside of your server feature, you can provide an import path to the client feature like this:
Add nodes to the nodes array in both your client & server feature. On the server side, nodes are utilized for backend operations like HTML conversion in a headless editor. On the client side, these nodes are integral to how content is displayed and managed in the editor, influencing how they are rendered, behave, and saved in the database.
Example:
myFeature/feature.client.ts:
This also supports lexical node replacements.
myFeature/nodes/MyNode.tsx:
Here is a basic DecoratorNode example:
Please do not add any 'use client' directives to your nodes, as the node class can be used on the server.
One small part of a feature are plugins. The name stems from the lexical playground plugins and is just a small part of a lexical feature. Plugins are simply React components which are added to the editor, within all the lexical context providers. They can be used to add any functionality to the editor, by utilizing the lexical API.
Most commonly, they are used to register lexical listeners, node transforms or commands. For example, you could add a drawer to your plugin and register a command which opens it. That command can then be called from anywhere within lexical, e.g. from within your custom lexical node.
To add a plugin, simply add it to the plugins array in your client feature:
Example plugin.tsx:
In this example, we register a lexical command, which simply inserts a new MyNode into the editor. This command can be called from anywhere within lexical, e.g. from within a custom node.
Toolbar groups are visual containers which hold toolbar items. There are different toolbar group types which determine how a toolbar item is displayed: dropdown and buttons.
All the default toolbar groups are exported from @payloadcms/richtext-lexical/client. You can use them to add your own toolbar items to the editor:
Within dropdown groups, items are positioned vertically when the dropdown is opened and include the icon & label. Within button groups, items are positioned horizontally and only include the icon. If a toolbar group with the same key is declared twice, all its items will be merged into one group.
 Option      
 Description                                                                                                                                            
 items 
 All toolbar items part of this toolbar group need to be added here.                                                                                    
 key 
 Each toolbar group needs to have a unique key. Groups with the same keys will have their items merged together.                                        
 order 
 Determines where the toolbar group will be.                                                                                                            
 type 
 Controls the toolbar group type. Set to buttons to create a buttons toolbar group, which displays toolbar items horizontally using only their icons. 
Example:
 Option               
 Description                                                                                                                                                                          
 items 
 All toolbar items part of this toolbar group need to be added here.                                                                                                                  
 key 
 Each toolbar group needs to have a unique key. Groups with the same keys will have their items merged together.                                                                      
 order 
 Determines where the toolbar group will be.                                                                                                                                          
 type 
 Controls the toolbar group type. Set to dropdown to create a buttons toolbar group, which displays toolbar items vertically using their icons and labels, if the dropdown is open. 
 ChildComponent 
 The dropdown toolbar ChildComponent allows you to pass in a React Component which will be displayed within the dropdown button.                                                      
Example:
Custom nodes and features on its own are pointless, if they can't be added to the editor. You will need to hook in one of our interfaces which allow the user to interact with the editor:
To add a toolbar item to either the floating or the inline toolbar, you can add a ToolbarGroup with a ToolbarItem to the toolbarFixed or toolbarInline props of your client feature:
You will have to provide a toolbar group first, and then the items for that toolbar group (more on that above).
A ToolbarItem various props you can use to customize its behavior:
 Option               
 Description                                                                                                                                                                                
 ChildComponent 
 A React component which is rendered within your toolbar item's default button component. Usually, you want this to be an icon.                                                             
 Component 
 A React component which is rendered in place of the toolbar item's default button component, thus completely replacing it. The ChildComponent and onSelect properties will be ignored. 
 label 
 The label will be displayed in your toolbar item, if it's within a dropdown group. To make use of i18n, this can be a function.                                                            
 key 
 Each toolbar item needs to have a unique key.                                                                                                                                              
 onSelect 
 A function which is called when the toolbar item is clicked.                                                                                                                               
 isEnabled 
 This is optional and controls if the toolbar item is clickable or not. If false is returned here, it will be grayed out and unclickable.                                                 
 isActive 
 This is optional and controls if the toolbar item is highlighted or not                                                                                                                    
The API for adding an item to the floating inline toolbar (toolbarInline) is identical. If you wanted to add an item to both the fixed and inline toolbar, you can extract it into its own variable (typed as ToolbarGroup[]) and add it to both the toolbarFixed and toolbarInline props.
We're exporting slashMenuBasicGroupWithItems from @payloadcms/richtext-lexical/client which you can use to add items to the slash menu labelled "Basic". If you want to create your own slash menu group, here is an example:
By creating a helper function like this, you can easily re-use it and add items to it. All Slash Menu groups with the same keys will have their items merged together.
 Option      
 Description                                                                                                                           
 items 
 An array of SlashMenuItem's which will be displayed in the slash menu.                                                              
 label 
 The label will be displayed before your Slash Menu group. In order to make use of i18n, this can be a function.                       
 key 
 Used for class names and, if label is not provided, for display. Slash menus with the same key will have their items merged together. 
The API for adding items to the slash menu is similar. There are slash menu groups, and each slash menu groups has items. Here is an example:
 Option         
 Description                                                                                                                                                                                                                                                                       
 Icon 
 The icon which is rendered in your slash menu item.                                                                                                                                                                                                                               
 label 
 The label will be displayed in your slash menu item. In order to make use of i18n, this can be a function.                                                                                                                                                                        
 key 
 Each slash menu item needs to have a unique key. The key will be matched when typing, displayed if no label property is set, and used for classNames.                                                                                                                           
 onSelect 
 A function which is called when the slash menu item is selected.                                                                                                                                                                                                                  
 keywords 
 Keywords are used to match the item for different texts typed after the '/'. E.g. you might want to show a horizontal rule item if you type both /hr, /separator, /horizontal etc. In addition to the keywords, the label and key will be used to find the right slash menu item. 
The Client Feature, just like the Server Feature, allows you to add markdown transformers. Markdown transformers on the client are used to create new nodes when a certain markdown pattern is typed in the editor.
In this example, a new MyNode will be inserted into the editor when `+++ ` is typed.
You can add providers to your client feature, which will be nested below the EditorConfigProvider. This can be useful if you want to provide some context to your nodes or other parts of your feature.
To accept props in your feature, type them as a generic.
Server Feature:
Client Feature:
The unSanitized props are what the user will pass to the feature when they call its provider function and add it to their editor config. You then have an option to sanitize those props. To sanitize those in the server feature, you can pass a function to feature instead of an object:
Keep in mind that any sanitized props then have to be returned in the sanitizedServerFeatureProps property.
In the client feature, it works similarly:
By default, the client feature will never receive any props from the server feature. In order to pass props from the server to the client, you can need to return those props in the server feature:
The reason the client feature does not have the same props available as the server by default is because all client props need to be serializable. You can totally accept things like functions or Maps as props in your server feature, but you will not be able to send those to the client. In the end, those props are sent from the server to the client over the network, so they need to be serializable.
Have a look at the features we've already built - understanding how they work will help you understand how to create your own. There is no difference between the features included by default and the ones you create yourself - since those features are all isolated from the "core", you have access to the same APIs, whether the feature is part of Payload or not!
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/rich-text/migration

While both Slate and Lexical save the editor state in JSON, the structure of the JSON is different.
Just import the migrateSlateToLexical function we provide, pass it the payload object and run it. Depending on the amount of collections, this might take a while.
IMPORTANT: This will overwrite all slate data. We recommend doing the following first:
One way to handle this is to just give your lexical editor the ability to read the slate JSON.
Simply add the SlateToLexicalFeature to your editor:
and done! Now, every time this lexical editor is initialized, it converts the slate date to lexical on-the-fly. If the data is already in lexical format, it will just pass it through.
This is by far the easiest way to migrate from Slate to Lexical, although it does come with a few caveats:
The easy way to solve this: Edit the richText field and save the document! This overrides the slate data with the lexical data, and the next time the document is loaded, the lexical data will be used. This solves both the performance and the output issue for that specific document. This, however, is a slow and gradual migration process, thus you will have to support both API formats. Especially for a large number of documents, we recommend running the migration script, as explained above.
If you have custom Slate nodes, create a custom converter for them. Here's the Upload converter as an example:
It's pretty simple: You get a Slate node as input, and you return the lexical node. The nodeTypes array is used to determine which Slate nodes this converter can handle.
When using a migration script, you can add your custom converters to the converters property of the convertSlateToLexical props, as seen in the example above.
When using the SlateToLexicalFeature, you can add your custom converters to the converters property of the SlateToLexicalFeature props:
Migrating from payload-plugin-lexical works similar to migrating from Slate.
Instead of a SlateToLexicalFeature there is a LexicalPluginToLexicalFeature you can use. And instead of convertSlateToLexical you can use convertLexicalPluginToLexical.
Each lexical node has a version property which is saved in the database. Every time we make a breaking change to the node's data, we increment the version. This way, we can detect an old version and automatically convert old data to the new format once you open up the editor.
The problem is, this migration only happens when you open the editor, modify the richText field (so that the field's setValue function is called) and save the document. Until you do that for all documents, some documents will still have the old data.
To solve this, we export an upgradeLexicalData function which goes through every single document in your Payload app and re-saves it, if it has a lexical editor. This way, the data is automatically converted to the new format, and that automatic conversion gets applied to every single document in your app.
IMPORTANT: Take a backup of your entire database. If anything goes wrong and you do not have a backup, you are on your own and will not receive any support.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/live-preview/overview

With Live Preview you can render your front-end application directly within the Admin Panel. As you type, your changes take effect in real-time. No need to save a draft or publish your changes. This works in both Server-side as well as Client-side environments.
Live Preview works by rendering an iframe on the page that loads your front-end application. The Admin Panel communicates with your app through window.postMessage events. These events are emitted every time a change is made to the Document. Your app then listens for these events and re-renders itself with the data it receives.
To add Live Preview, use the admin.livePreview property in your Payload Config:
Reminder: Alternatively, you can define the admin.livePreview property on individual Collection Admin Configs and Global Admin Configs. Settings defined here will be merged into the top-level as overrides.
Setting up Live Preview is easy. This can be done either globally through the Root Admin Config, or on individual Collection Admin Configs and Global Admin Configs. Once configured, a new "Live Preview" tab will appear at the top of enabled Documents. Navigating to this tab opens the preview window and loads your front-end application.
The following options are available:
 Path              
 Description                                                                                                                                           
 url *      
 String, or function that returns a string, pointing to your front-end application. This value is used as the iframe src. More details.      
 breakpoints 
 Array of breakpoints to be used as “device sizes” in the preview window. Each item appears as an option in the toolbar. More details. 
 collections 
 Array of collection slugs to enable Live Preview on.                                                                                                  
 globals 
 Array of global slugs to enable Live Preview on.                                                                                                      
* An asterisk denotes that a property is required.
The url property resolves to a string that points to your front-end application. This value is used as the src attribute of the iframe rendering your front-end. Once loaded, the Admin Panel will communicate directly with your app through window.postMessage events.
To set the URL, use the admin.livePreview.url property in your Payload Config:
You can also pass a function in order to dynamically format URLs. This is useful for multi-tenant applications, localization, or any other scenario where the URL needs to be generated based on the Document being edited.
To set dynamic URLs, set the admin.livePreview.url property in your Payload Config to a function:
The following arguments are provided to the url function:
 Path                   
 Description                                                                                                           
 data 
 The data of the Document being edited. This includes changes that have not yet been saved.                            
 locale 
 The locale currently being edited (if applicable). More details.                     
 collectionConfig 
 The Collection Admin Config of the Document being edited. More details. 
 globalConfig 
 The Global Admin Config of the Document being edited. More details.         
 req 
 The Payload Request object.                                                                                           
You can return either an absolute URL or relative URL from this function. If you don't know the URL of your frontend at build-time, you can return a relative URL, and in that case, Payload will automatically construct an absolute URL by injecting the protocol, domain, and port from your browser window. Returning a relative URL is helpful for platforms like Vercel where you may have preview deployment URLs that are unknown at build time.
If your application requires a fully qualified URL, or you are attempting to preview with a frontend on a different domain, you can use the req property to build this URL:
The breakpoints property is an array of objects which are used as “device sizes” in the preview window. Each item will render as an option in the toolbar. When selected, the preview window will resize to the exact dimensions specified in that breakpoint.
To set breakpoints, use the admin.livePreview.breakpoints property in your Payload Config:
The following options are available for each breakpoint:
 Path            
 Description                                                                 
 label *  
 The label to display in the drop-down. This is what the user will see.      
 name *   
 The name of the breakpoint.                                                 
 width *  
 The width of the breakpoint. This is used to set the width of the iframe.   
 height * 
 The height of the breakpoint. This is used to set the height of the iframe. 
* An asterisk denotes that a property is required.
The "Responsive" option is always available in the drop-down and requires no additional configuration. This is the default breakpoint that will be used on initial load. This option styles the iframe with a width and height of 100% so that it fills the screen at its maximum size and automatically resizes as the window changes size.
You may also explicitly resize the Live Preview by using the corresponding inputs in the toolbar. This will temporarily override the breakpoint selection to "Custom" until a predefined breakpoint is selected once again.
If you prefer to freely resize the Live Preview without the use of breakpoints, you can open it in a new window by clicking the button in the toolbar. This will close the iframe and open a new window which can be resized as you wish. Closing it will automatically re-open the iframe.
For a working demonstration of this, check out the official Live Preview Example.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/live-preview/frontend

There are two ways to use Live Preview in your own application depending on whether your front-end framework supports Server Components:
We suggest using server-side Live Preview if your framework supports Server Components, it is both simpler to setup and more performant to run than the client-side alternative.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/live-preview/server

Server-side Live Preview is only for front-end frameworks that support the concept of Server Components, i.e. React Server Components. If your front-end application is built with a client-side framework like the Next.js Pages Router, React Router, Vue 3, etc., see client-side Live Preview.
Server-side Live Preview works by making a roundtrip to the server every time your document is saved, i.e. draft save, autosave, or publish. While using Live Preview, the Admin Panel emits a new window.postMessage event which your front-end application can use to invoke this process. In Next.js, this means simply calling router.refresh() which will hydrate the HTML using new data straight from the Local API.
It is recommended that you enable Autosave alongside Live Preview to make the experience feel more responsive.
If your front-end application is built with React, you can use the RefreshRouteOnChange function that Payload provides. In the future, all other major frameworks like Vue and Svelte will be officially supported. If you are using any of these frameworks today, you can still integrate with Live Preview yourself using the underlying tooling that Payload provides. See building your own router refresh component for more information.
If your front-end application is built with server-side React like Next.js App Router, you can use the RefreshRouteOnSave component that Payload provides.
First, install the @payloadcms/live-preview-react package:
Then, render the RefreshRouteOnSave component anywhere in your page.tsx. Here's an example:
page.tsx:
RefreshRouteOnSave.tsx:
No matter what front-end framework you are using, you can build your own component using the same underlying tooling that Payload provides.
First, install the base @payloadcms/live-preview package:
This package provides the following functions:
 Path                  
 Description                                                                                                                        
 ready 
 Sends a window.postMessage event to the Admin Panel to indicate that the front-end is ready to receive messages.                 
 isDocumentEvent 
 Checks if a MessageEvent originates from the Admin Panel and is a document-level event, i.e. draft save, autosave, publish, etc. 
With these functions, you can build your own hook using your front-end framework of choice:
Here is an example of what the same RefreshRouteOnSave React component from above looks like under the hood:
For a working demonstration of this, check out the official Live Preview Example. There you will find a fully working example of how to implement Live Preview in your Next.js App Router application.
If you are noticing that updates feel less snappy than client-side Live Preview (i.e. the useLivePreview hook), this is because of how the two differ in how they work—instead of emitting events against form state, server-side Live Preview refreshes the route after a new document is saved.
Use Autosave to mimic this effect server-side. Try decreasing the value of versions.autoSave.interval to make the experience feel more responsive:
If your front-end application has set a Content Security Policy (CSP) that blocks the Admin Panel from loading your front-end application, the iframe will not be able to load your site. To resolve this, you can whitelist the Admin Panel's domain in your CSP by setting the frame-ancestors directive:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/live-preview/client

If your front-end application supports Server Components like the Next.js App Router, etc., we suggest setting up server-side Live Preview instead.
While using Live Preview, the Admin Panel emits a new window.postMessage event every time your document has changed. Your front-end application can listen for these events and re-render accordingly.
If your front-end application is built with React or Vue, use the useLivePreview hooks that Payload provides. In the future, all other major frameworks like Svelte will be officially supported. If you are using any of these frameworks today, you can still integrate with Live Preview yourself using the underlying tooling that Payload provides. See building your own hook for more information.
By default, all hooks accept the following args:
 Path               
 Description                                                                            
 serverURL * 
 The URL of your Payload server.                                                        
 initialData 
 The initial data of the document. The live data will be merged in as changes are made. 
 depth 
 The depth of the relationships to fetch. Defaults to 0.                              
 apiRoute 
 The path of your API route as defined in routes.api. Defaults to /api.             
* An asterisk denotes that a property is required.
And return the following values:
 Path            
 Description                                                      
 data 
 The live data of the document, merged with the initial data.     
 isLoading 
 A boolean that indicates whether or not the document is loading. 
If your front-end is tightly coupled to required fields, you should ensure that your UI does not break when these fields are removed. For example, if you are rendering something like data.relatedPosts[0].title, your page will break once you remove the first related post. To get around this, use conditional logic, optional chaining, or default values in your UI where needed. For example, data?.relatedPosts?.[0]?.title.
It is important that the depth argument matches exactly with the depth of your initial page request. The depth property is used to populated relationships and uploads beyond their IDs. See Depth for more information.
Live Preview will work with any front-end framework that supports the native window.postMessage API. By default, Payload officially supports the most popular frameworks, including:
If your framework is not listed, you can still integrate with Live Preview using the underlying tooling that Payload provides. More details.
If your front-end application is built with client-side React like Next.js Pages Router, you can use the useLivePreview hook that Payload provides.
First, install the @payloadcms/live-preview-react package:
Then, use the useLivePreview hook in your React component:
Reminder: If you are using React Server Components, we strongly suggest setting up server-side Live Preview instead.
If your front-end application is built with Vue 3 or Nuxt 3, you can use the useLivePreview composable that Payload provides.
First, install the @payloadcms/live-preview-vue package:
Then, use the useLivePreview hook in your Vue component:
No matter what front-end framework you are using, you can build your own hook using the same underlying tooling that Payload provides.
First, install the base @payloadcms/live-preview package:
This package provides the following functions:
 Path                     
 Description                                                                                                        
 subscribe 
 Subscribes to the Admin Panel's window.postMessage events and calls the provided callback function.              
 unsubscribe 
 Unsubscribes from the Admin Panel's window.postMessage events.                                                   
 ready 
 Sends a window.postMessage event to the Admin Panel to indicate that the front-end is ready to receive messages. 
 isLivePreviewEvent 
 Checks if a MessageEvent originates from the Admin Panel and is a Live Preview event, i.e. debounced form state. 
The subscribe function takes the following args:
 Path               
 Description                                                                                 
 callback *  
 A callback function that is called with data every time a change is made to the document. 
 serverURL * 
 The URL of your Payload server.                                                             
 initialData 
 The initial data of the document. The live data will be merged in as changes are made.      
 depth 
 The depth of the relationships to fetch. Defaults to 0.                                   
With these functions, you can build your own hook using your front-end framework of choice:
Here is an example of what the same useLivePreview React hook from above looks like under the hood:
When building your own hook, ensure that the args and return values are consistent with the ones listed at the top of this document. This will ensure that all hooks follow the same API.
For a working demonstration of this, check out the official Live Preview Example. There you will find an example of a fully integrated Next.js App Router front-end that runs on the same server as Payload.
If you are using relationships or uploads in your front-end application, and your front-end application runs on a different domain than your Payload server, you may need to configure CORS to allow requests to be made between the two domains. This includes sites that are running on a different port or subdomain. Similarly, if you are protecting resources behind user authentication, you may also need to configure CSRF to allow cookies to be sent between the two domains. For example:
It is possible that either you are setting an improper depth in your initial request and/or your useLivePreview hook, or they're mismatched. Ensure that the depth parameter is set to the correct value, and that it matches exactly in both places. For example:
If your front-end application has set a Content Security Policy (CSP) that blocks the Admin Panel from loading your front-end application, the iframe will not be able to load your site. To resolve this, you can whitelist the Admin Panel's domain in your CSP by setting the frame-ancestors directive:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/versions/overview

Payload's powerful Versions functionality allows you to keep a running history of changes over time and extensible to fit any content publishing workflow.
When enabled, Payload will automatically scaffold a new Collection in your database to store versions of your document(s) over time, and the Admin UI will be extended with additional views that allow you to browse document versions, view diffs in order to see exactly what has changed in your documents (and when they changed), and restore documents back to prior versions easily.
Comparing an old version to a newer version of a document
With Versions, you can:
Versions are extremely performant and totally opt-in. They don't change the shape of your data at all. All versions are stored in a separate Collection and can be turned on and off easily at your discretion.
Versions support a few different levels of functionality that each come with their own impacts to document workflow.
If you enable versions but keep draft mode disabled, Payload will simply create a new version of a document each time you update a document. This is great for use cases where you need to retain a history of all document updates over time, but always want to treat the newest document version as the version that is "published".
For example, a use case for "versions enabled, drafts disabled" could be on a collection of users, where you might want to keep a version history (or audit log) of all changes ever made to users - but any changes to users should always be treated as "published" and you have no need to maintain a "draft" version of a user.
If you have versions and drafts enabled, you are able to control which documents are published, and which are considered draft. That lets you write Access Control to control who can see published documents, and who can see draft documents. It also lets you save versions (drafts) that are newer than your most recently published document, which is helpful if you want to draft changes and maybe even preview them before you publish the changes. Read more about Drafts here.
When you have versions, drafts, and autosave enabled, the Admin UI will automatically save changes that you make to a new draft version as you edit a document, which makes sure that you never lose your changes ever again. Autosave will not affect your published post at all—instead, it'll just save your changes and let you publish them whenever you or your editors are ready to do so. Read more about Autosave here.
Configuring Versions is done by adding the versions key to your Collection configs. Set it to true to enable default Versions settings, or customize versions options by setting the property equal to an object containing the following available options:
 Option      
 Description                                                                                                                                                        
 maxPerDoc 
 Use this setting to control how many versions to keep on a document by document basis. Must be an integer. Defaults to 100, use 0 to save all versions.            
 drafts 
 Enable Drafts mode for this collection. To enable, set to true or pass an object with draft options. 
Global versions work similarly to Collection versions but have a slightly different set of config properties supported.
 Option   
 Description                                                                                                                                                   
 max 
 Use this setting to control how many versions to keep on a global by global basis. Must be an integer.                                                        
 drafts 
 Enable Drafts mode for this global. To enable, set to true or pass an object with draft options 
By enabling versions, a new database collection will be made to store versions for your collection or global. The collection will be named based off the slug of the collection or global and will follow this pattern (where slug is replaced with the slug of your collection or global):
Each document in this new versions collection will store a set of meta properties about the version as well as a full copy of the document. For example, a version's data might look like this for a Collection document:
Global versions are stored the same as the collection version shown above, except they do not feature the parent property, as each Global receives its own versions collection. That means we know that all versions in that collection correspond to that specific global.
Versions expose new operations for both collections and globals. They allow you to find and query versions, find a single version by ID, and publish (or restore) a version by ID. Both Collections and Globals support the same new operations. They are used primarily by the admin UI, but if you are writing custom logic in your app and would like to utilize them, they're available for you to use as well via REST, GraphQL, and Local APIs.
Collection REST endpoints:
 Method 
 Path                                 
 Description                       
 GET 
 /api/{collectionSlug}/versions 
 Find and query paginated versions 
 GET 
 /api/{collectionSlug}/versions/:id 
 Find a specific version by ID     
 POST 
 /api/{collectionSlug}/versions/:id 
 Restore a version by ID           
Collection GraphQL queries:
 Query Name                               
 Operation         
 version{collection.label.singular} 
 findVersionByID 
 versions{collection.label.plural} 
 findVersions 
And mutation:
 Query Name                                      
 Operation        
 restoreVersion{collection.label.singular} 
 restoreVersion 
Collection Local API methods:
Global REST endpoints:
 Method 
 Path                                     
 Description                       
 GET 
 /api/globals/{globalSlug}/versions 
 Find and query paginated versions 
 GET 
 /api/globals/{globalSlug}/versions/:id 
 Find a specific version by ID     
 POST 
 /api/globals/{globalSlug}/versions/:id 
 Restore a version by ID           
Global GraphQL queries:
 Query Name                   
 Operation         
 version{global.label} 
 findVersionByID 
 versions{global.label} 
 findVersions 
Global GraphQL mutation:
 Query Name                         
 Operation        
 restoreVersion{global.label} 
 restoreVersion 
Global Local API methods:
Versions expose a new Access Control function on both Collections and Globals that allow for you to control who can see versions of documents, and who can't.
 Function           
 Allows/Denies Access                                                                                                   
 readVersions 
 Used to control who can read versions, and who can't. Will automatically restrict the Admin UI version viewing access. 
For full details on how to use Access Control with Versions, see the Access Control documentation.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/versions/drafts

Payload's Draft functionality builds on top of the Versions functionality to allow you to make changes to your collection documents and globals, but publish only when you're ready. This functionality allows you to build powerful Preview environments for your data, where you can make sure your changes look good before publishing documents.
Drafts rely on Versions being enabled in order to function.
By enabling Versions with Drafts, your collections and globals can maintain newer, and unpublished versions of your documents. It's perfect for cases where you might want to work on a document, update it and save your progress, but not necessarily make it publicly published right away. Drafts are extremely helpful when building preview implementations.
If Drafts are enabled, the typical Save button is replaced with new actions which allow you to either save a draft, or publish your changes.
Collections and Globals both support the same options for configuring drafts. You can either set versions.drafts to true, or pass an object to configure draft properties.
 Draft Option      
 Description                                                                                                                                                      
 autosave 
 Enable autosave to automatically save progress while documents are edited. To enable, set to true or pass an object with options. 
 schedulePublish 
 Allow for editors to schedule publish / unpublish events in the future. More 
 validate 
 Set validate to true to validate draft documents when saved. Default is false.                                                                             
By enabling drafts on a collection or a global, Payload will automatically inject a new field into your schema called _status. The _status field is used internally by Payload to store if a document is set to draft or published.
Admin UI status indication
Within the Admin UI, if drafts are enabled, a document can be shown with one of three "statuses":
If drafts are enabled on your collection or global, important and powerful changes are made to your REST, GraphQL, and Local APIs that allow you to specify if you are interacting with drafts or with live documents.
If you enable drafts on a collection or global, the create and update operations for REST, GraphQL, and Local APIs expose a new option called draft which allows you to specify if you are creating or updating a draft, or if you're just sending your changes straight to the published document. For example, if you pass the query parameter ?draft=true to a REST create or update operation, your action will be treated as if you are creating a draft and not a published document. By default, the draft argument is set to false.
Required fields
If draft is enabled while creating or updating a document, all fields are considered as not required, so that you can save drafts that are incomplete.
In addition to the draft argument within create and update operations, a draft argument is also exposed for find and findByID operations.
If draft is set to true while reading a document, Payload will automatically replace returned document(s) with their newest drafts if any newer drafts are available.
For example, let's take the following scenario:
Here, you will have a published document that resides in your main collection, and then you'll have two newer drafts that reside in the _[collectionSlug]_versions database collection.
If you simply fetch your created document using a find or findByID operation, your published document will be returned and the drafts will be ignored.
But, if you specify draft as true, Payload will automatically replace your published document's content with content coming from the most recently saved version. In this case, as we have created two versions in the above scenario, Payload will send back data from the newest (second) draft and your document will appear as the most recently drafted version instead of the published version.
Important: the draft argument on its own will not restrict documents with _status: 'draft' from being returned from the API. You need to use Access Control to prevent documents with _status: 'draft' from being returned to unauthenticated users. Read below for more information on how this works.
If you're using the drafts feature, it's important for you to consider who can view your drafts, and who can view only published documents. Luckily, Payload makes this extremely simple and puts the power completely in your hands.
You can use the read Access Control method to restrict who is able to view drafts of your documents by simply returning a query constraint which restricts the documents that any given user is able to retrieve.
Here is an example that utilizes the _status field to require a user to be logged in to retrieve drafts:
 Note regarding adding versions to an existing collection
If you already have a collection with documents, and you opt in to draft functionality after you have already created existing documents, all of your old documents _will not have a _status field_ until you resave them. For this reason, if you are _adding_ versions into an existing collection, you might want to write your Access Control function to allow for users to read both documents where _status is equal to "published" as well as where _status does not exist.
Here is an example for how to write an Access Control function that grants access to both documents where _status is equal to "published" and where _status does not exist:
Payload provides for an ability to schedule publishing / unpublishing events in the future, which can be helpful if you need to set certain documents to "go live" at a given date in the future, or, vice versa, revert to a draft state after a certain time has passed.
You can enable this functionality on both collections and globals via the versions.drafts.schedulePublish: true property.
Important: if you are going to enable scheduled publish / unpublish, you need to make sure your Payload app is set up to process Jobs. This feature works by creating a Job in the background, which will be picked up after the job becomes available. If you do not have any mechanism in place to run jobs, your scheduled publish / unpublish jobs will never be executed.
If a document is published, the Payload Admin UI will be updated to show an "unpublish" button at the top of the sidebar, which will "unpublish" the currently published document. Consider this as a way to "revert" a document back to a draft state. On the API side, this is done by simply setting _status: 'draft' on any document.
If a document is published, and you have made further changes which are saved as a draft, Payload will show a "revert to published" button at the top of the sidebar which will allow you to reject your draft changes and "revert" back to the published state of the document. Your drafts will still be saved, but a new version will be created that will reflect the last published state of the document.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/versions/autosave

Extending on Payload's Draft functionality, you can configure your collections and globals to autosave changes as drafts, and publish only you're ready. The Admin UI will automatically adapt to autosaving progress at an interval that you define, and will store all autosaved changes as a new Draft version. Never lose your work - and publish changes to the live document only when you're ready.
Autosave relies on Versions and Drafts being enabled in order to function.
If Autosave is enabled, drafts will be created automatically as the document is modified and the Admin UI adds an indicator describing when the document was last saved to the top right of the sidebar.
Collections and Globals both support the same options for configuring autosave. You can either set versions.drafts.autosave to true, or pass an object to configure autosave properties.
 Drafts Autosave Options 
 Description                                                                                                                                                           
 interval 
 Define an interval in milliseconds to automatically save progress while documents are edited. Document updates are "debounced" at this interval. Defaults to 800. 
Example config with versions, drafts, and autosave enabled:
When autosave is enabled, all update operations within Payload expose a new argument called autosave. When set to true, Payload will treat the incoming draft update as an autosave. This is primarily used by the Admin UI, but there may be some cases where you are building an app for your users and wish to implement autosave in your own app. To do so, use the autosave argument in your update operations.
If we created a new version for each autosave, you'd quickly find a ton of autosaves that clutter up your _versions collection within the database. That would be messy quick because autosave is typically set to save a document at ~800ms intervals.
Instead of creating a new version each time a document is autosaved, Payload smartly only creates one autosave version, and then updates that specific version with each autosave performed. This makes sure that your versions remain nice and tidy.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/upload/overview

Payload provides everything you need to enable file upload, storage, and management directly on your server—including extremely powerful file access control.
Here are some common use cases of Uploads:
By simply enabling Upload functionality on a Collection, Payload will automatically transform your Collection into a robust file management / storage solution. The following modifications will be made:
Every Payload Collection can opt-in to supporting Uploads by specifying the upload property on the Collection's config to either true or to an object containing upload options.
 Tip:
A common pattern is to create a "media" collection and enable upload on that collection.
An asterisk denotes that an option is required.
 Option                         
 Description                                                                                                                                                                                                                                        
 adminThumbnail 
 Set the way that the Admin Panel will display thumbnails for this Collection. More 
 bulkUpload 
 Allow users to upload in bulk from the list view, default is true                                                                                                                                                                                  
 cacheTags 
 Set to false to disable the cache tag set in the UI for the admin thumbnail component. Useful for when CDNs don't allow certain cache queries.                                                                                                   
 crop 
 Set to false to disable the cropping tool in the Admin Panel. Crop is enabled by default. More 
 disableLocalStorage 
 Completely disable uploading files to disk locally. More 
 displayPreview 
 Enable displaying preview of the uploaded file in Upload fields related to this Collection. Can be locally overridden by displayPreview option in Upload field. More.                                      
 externalFileHeaderFilter 
 Accepts existing headers and returns the headers after filtering or modifying.                                                                                                                                                                     
 filesRequiredOnCreate 
 Mandate file data on creation, default is true.                                                                                                                                                                                                    
 filenameCompoundIndex 
 Field slugs to use for a compound index instead of the default filename index.                                                                                                                                                                     
 focalPoint 
 Set to false to disable the focal point selection tool in the Admin Panel. The focal point selector is only available when imageSizes or resizeOptions are defined. More 
 formatOptions 
 An object with format and options that are used with the Sharp image library to format the upload file. More 
 handlers 
 Array of Request handlers to execute when fetching a file, if a handler returns a Response it will be sent to the client. Otherwise Payload will retrieve and send back the file.                                                                  
 imageSizes 
 If specified, image uploads will be automatically resized in accordance to these image sizes. More 
 mimeTypes 
 Restrict mimeTypes in the file picker. Array of valid mimetypes or mimetype wildcards More 
 pasteURL 
 Controls whether files can be uploaded from remote URLs by pasting them into the Upload field. Enabled by default. Accepts false to disable or an object with an allowList of valid remote URLs. More 
 resizeOptions 
 An object passed to the the Sharp image library to resize the uploaded file. More 
 staticDir 
 The folder directory to use to store media in. Can be either an absolute path or relative to the directory that contains your config. Defaults to your collection slug                                                                             
 trimOptions 
 An object passed to the the Sharp image library to trim the uploaded file. More 
 withMetadata 
 If specified, appends metadata to the output image file. Accepts a boolean or a function that receives metadata and req, returning a boolean.                                                                                                  
 hideFileInputOnCreate 
 Set to true to prevent the admin UI from showing file inputs during document creation, useful for programmatic file generation.                                                                                                                  
 hideRemoveFile 
 Set to true to prevent the admin UI having a way to remove an existing file while editing.                                                                                                                                                       
Upload options are specifiable on a Collection by Collection basis, you can also control app wide options by passing your base Payload Config an upload property containing an object supportive of all Busboy configuration options.
 Option                   
 Description                                                                                                                                                                        
 abortOnLimit 
 A boolean that, if true, returns HTTP 413 if a file exceeds the file size limit. If false, the file is truncated. Defaults to false.                                         
 createParentPath 
 Set to true to automatically create a directory path when moving files from a temporary directory or buffer. Defaults to false.                                                
 debug 
 A boolean that turns upload process logging on if true, or off if false. Useful for troubleshooting. Defaults to false.                                                      
 limitHandler 
 A function which is invoked if the file is greater than configured limits.                                                                                                         
 parseNested 
 Set to true to turn req.body and req.files into nested structures. By default req.body and req.files are flat objects. Defaults to false.                              
 preserveExtension 
 Preserves file extensions with the safeFileNames option. Limits file names to 3 characters if true or a custom length if a number, trimming from the start of the extension. 
 responseOnLimit 
 A string that is sent in the Response to a client if the file size limit is exceeded when used with abortOnLimit.                                                              
 safeFileNames 
 Set to true to strip non-alphanumeric characters except dashes and underscores. Can also be set to a regex to determine what to strip. Defaults to false.                      
 tempFileDir 
 A string path to store temporary files used when the useTempFiles option is set to true. Defaults to './tmp'.                                                              
 uploadTimeout 
 A number that defines how long to wait for data before aborting, specified in milliseconds. Set to 0 to disable timeout checks. Defaults to 60000.                           
 uriDecodeFileNames 
 Set to true to apply uri decoding to file names. Defaults to false.                                                                                                            
 useTempFiles 
 Set to true to store files to a temporary directory instead of in RAM, reducing memory usage for large files or many files.                                                      
Click here for more documentation about what you can control with Busboy.
A common example of what you might want to customize within Payload-wide Upload options would be to increase the allowed fileSize of uploads sent to Payload:
You can customize the filename before it's uploaded to the server by using a beforeOperation hook.
The req.file object will have additional information about the file, such as mimeType and extension, and you also have full access to the file data itself. The filename from here will also be threaded to image sizes if they're enabled.
If you specify an array of imageSizes to your upload config, Payload will automatically crop and resize your uploads to fit each of the sizes specified by your config.
The Admin Panel will also automatically display all available files, including width, height, and file size, for each of your uploaded files.
Behind the scenes, Payload relies on sharp to perform its image resizing. You can specify additional options for sharp to use while resizing your images.
Note that for image resizing to work, sharp must be specified in your Payload Config. This is configured by default if you created your Payload project with create-payload-app. See sharp in Config Options.
All auto-resized images are exposed to be re-used in hooks and similar via an object that is bound to req.payloadUploadSizes.
The object will have keys for each size generated, and each key will be set equal to a buffer containing the file data.
When an uploaded image is smaller than the defined image size, we have 3 options:
withoutEnlargement: undefined | false | true
 Note:
By default, the image size will return NULL when the uploaded image is smaller than the defined image size. Use the withoutEnlargement prop to change this.
Each image size supports a generateImageName function that can be used to generate a custom file name for the resized image. This function receives the original file name, the resize name, the extension, height and width as arguments.
This feature is only available for image file types.
Setting crop: false and focalPoint: false in your Upload config will be disable the respective selector in the Admin Panel.
Image cropping occurs before any resizing, the resized images will therefore be generated from the cropped image (not the original image).
If no resizing options are specified (imageSizes or resizeOptions), the focal point selector will not be displayed.
If you are using a plugin to send your files off to a third-party file storage host or CDN, like Amazon S3 or similar, you may not want to store your files locally at all. You can prevent Payload from writing files to disk by specifying disableLocalStorage: true on your collection's upload config.
 Note:
This is a fairly advanced feature. If you do disable local file storage, by default, your admin panel's thumbnails will be broken as you will not have stored a file. It will be totally up to you to use either a plugin or your own hooks to store your files in a permanent manner, as well as provide your own admin thumbnail using upload.adminThumbnail.
You can specify how Payload retrieves admin thumbnails for your upload-enabled Collections with one of the following:
Specifying the mimeTypes property can restrict what files are allowed from the user's file picker. This accepts an array of strings, which can be any valid mimetype or mimetype wildcards
Some example values are: image/*, audio/*, video/*, image/png, application/pdf
Example mimeTypes usage:
 Important:
Uploading files is currently only possible through the REST and Local APIs due to how GraphQL works. It's difficult and fairly nonsensical to support uploading files through GraphQL.
To upload a file, use your collection's create endpoint. Send it all the data that your Collection requires, as well as a file key containing the file that you'd like to upload.
Send your request as a multipart/form-data request, using FormData if possible.
If you want to upload a file stored on your machine directly using the payload.create method, for example, during a seed script, you can use the filePath property to specify the local path of the file.
The data property should still include all the required fields of your media collection.
 Important:
Remember that all custom hooks attached to the media collection will still trigger. Ensure that files match the specified mimeTypes or sizes defined in the collection's formatOptions or custom hooks.
The pasteURL option allows users to fetch files from remote URLs by pasting them into an Upload field. This option is enabled by default and can be configured to either allow unrestricted client-side fetching or restrict server-side fetching to specific trusted domains.
By default, Payload uses client-side fetching, where the browser downloads the file directly from the provided URL. However, client-side fetching will fail if the URL’s server has CORS restrictions, making it suitable only for internal URLs or public URLs without CORS blocks.
To fetch files from restricted URLs that would otherwise be blocked by CORS, use server-side fetching by configuring the pasteURL option with an allowList of trusted domains. This method ensures that Payload downloads the file on the server and streams it to the browser. However, for security reasons, only URLs that match the specified allowList will be allowed.
Here’s how to configure the pasteURL option to control remote URL fetching:
 Option          
 Description                                                                                                                                                    
 undefined 
 Default behavior. Enables client-side fetching for internal or public URLs.                                                                                    
 false 
 Disables the ability to paste URLs into Upload fields.                                                                                                         
 allowList 
 Enables server-side fetching for specific trusted URLs. Requires an array of objects defining trusted domains. See the table below for details on AllowItem. 
An asterisk denotes that an option is required.
 Option            
 Description                                                                                          
 Example       
 hostname * 
 The hostname of the allowed URL. This is required to ensure the URL is coming from a trusted source. 
 example.com 
 pathname 
 The path portion of the URL. Supports wildcards to match multiple paths.                             
 /images/* 
 port 
 The port number of the URL. If not specified, the default port for the protocol will be used.        
 3000 
 protocol 
 The protocol to match. Must be either http or https. Defaults to https.                        
 https 
 search 
 The query string of the URL. If specified, the URL must match this exact query string.               
 ?version=1 
All files that are uploaded to each Collection automatically support the read Access Control function from the Collection itself. You can use this to control who should be allowed to see your uploads, and who should not.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/upload/storage-adapters

Payload offers additional storage adapters to handle file uploads. These adapters allow you to store files in different locations, such as Amazon S3, Vercel Blob Storage, Google Cloud Storage, and more.
 Service              
 Package                                                                                                           
 Vercel Blob          
 @payloadcms/storage-vercel-blob 
 AWS S3               
 @payloadcms/storage-s3 
 Azure                
 @payloadcms/storage-azure 
 Google Cloud Storage 
 @payloadcms/storage-gcs 
 Uploadthing          
 @payloadcms/storage-uploadthing 
@payloadcms/storage-vercel-blob
 Option               
 Description                                                          
 Default                       
 enabled 
 Whether or not to enable the plugin                                  
 true 
 collections 
 Collections to apply the Vercel Blob adapter to                      
 addRandomSuffix 
 Add a random suffix to the uploaded file name in Vercel Blob storage 
 false 
 cacheControlMaxAge 
 Cache-Control max-age in seconds                                     
 365 * 24 * 60 * 60 (1 Year) 
 token 
 Vercel Blob storage read/write token                                 
 '' 
 clientUploads 
 Do uploads directly on the client to bypass limits on Vercel.        
@payloadcms/storage-s3
See the the AWS SDK Package and S3ClientConfig object for guidance on AWS S3 configuration.
@payloadcms/storage-azure
 Option                 
 Description                                                              
 Default 
 enabled 
 Whether or not to enable the plugin                                      
 true 
 collections 
 Collections to apply the Azure Blob adapter to                           
 allowContainerCreate 
 Whether or not to allow the container to be created if it does not exist 
 false 
 baseURL 
 Base URL for the Azure Blob storage account                              
 connectionString 
 Azure Blob storage connection string                                     
 containerName 
 Azure Blob storage container name                                        
 clientUploads 
 Do uploads directly on the client to bypass limits on Vercel.            
@payloadcms/storage-gcs
 Option          
 Description                                                                                         
 Default   
 enabled 
 Whether or not to enable the plugin                                                                 
 true 
 collections 
 Collections to apply the storage to                                                                 
 bucket 
 The name of the bucket to use                                                                       
 options 
 Google Cloud Storage client configuration. See Docs 
 acl 
 Access control list for files that are uploaded                                                     
 Private 
 clientUploads 
 Do uploads directly on the client to bypass limits on Vercel.                                       
@payloadcms/storage-uploadthing
 Option           
 Description                                                   
 Default       
 token 
 Token from Uploadthing. Required.                             
 acl 
 Access control list for files that are uploaded               
 public-read 
 logLevel 
 Log level for Uploadthing                                     
 info 
 fetch 
 Custom fetch function                                         
 fetch 
 defaultKeyType 
 Default key type for file operations                          
 fileKey 
 clientUploads 
 Do uploads directly on the client to bypass limits on Vercel. 
If you need to create a custom storage adapter, you can use the @payloadcms/plugin-cloud-storage package. This package is used internally by the storage adapters mentioned above.
pnpm add @payloadcms/plugin-cloud-storage
Reference any of the existing storage adapters for guidance on how this should be structured. Create an adapter following the GeneratedAdapter interface. Then, pass the adapter to the cloudStorage plugin.
This plugin is configurable to work across many different Payload collections. A * denotes that the property is required.
 Option           
 Type                                
 Description                                                                                                                       
 collections * 
 Record<string, CollectionOptions> 
 Object with keys set to the slug of collections you want to enable the plugin for, and values set to collection-specific options. 
 enabled 
 boolean 
 To conditionally enable/disable plugin. Default: true.                                                                          
 Option                        
 Type                                                                                                              
 Description                                                                                                                                                                                                   
 adapter *                  
 Adapter 
 Pass in the adapter that you'd like to use for this collection. You can also set this field to null for local development if you'd like to bypass cloud storage in certain scenarios and use local storage. 
 disableLocalStorage 
 boolean 
 Choose to disable local storage on this collection. Defaults to true.                                                                                                                                       
 disablePayloadAccessControl 
 true 
 Set to true to disable Payload's Access Control. More 
 prefix 
 string 
 Set to media/images to upload files inside media/images folder in the bucket.                                                                                                                             
 generateFileURL 
 GenerateFileURL 
 Override the generated file URL with one that you create.                                                                                                                                                     
Payload ships with Access Control that runs even on statically served files. The same read Access Control property on your upload-enabled collections is used, and it allows you to restrict who can request your uploaded files.
To preserve this feature, by default, this plugin keeps all file URLs exactly the same. Your file URLs won't be updated to point directly to your cloud storage source, as in that case, Payload's Access control will be completely bypassed and you would need public readability on your cloud-hosted files.
Instead, all uploads will still be reached from the default /collectionSlug/staticURL/filename path. This plugin will "pass through" all files that are hosted on your third-party cloud service—with the added benefit of keeping your existing Access Control in place.
If this does not apply to you (your upload collection has read: () => true or similar) you can disable this functionality by setting disablePayloadAccessControl to true. When this setting is in place, this plugin will update your file URLs to point directly to your cloud host.
The proper way to conditionally enable/disable this plugin is to use the enabled property.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/email/overview

Payload has a few email adapters that can be imported to enable email functionality. The @payloadcms/email-nodemailer package will be the package most will want to install. This package provides an easy way to use Nodemailer for email and won't get in your way for those already familiar.
The email adapter should be passed into the email property of the Payload Config. This will allow Payload to send auth-related emails for things like password resets, new user verification, and any other email sending needs you may have.
When email is not needed or desired, Payload will log a warning on startup notifying that email is not configured. A warning message will also be logged on any attempt to send an email.
An email adapter will require at least the following fields:
 Option                      
 Description                                                                      
 defaultFromName *    
 The name part of the From field that will be seen on the delivered email         
 defaultFromAddress * 
 The email address part of the From field that will be used when delivering email 
 Name       
 Package                                                                                    
 Description                                                                                                                                                                                     
 Nodemailer 
 @payloadcms/email-nodemailer 
 Use any Nodemailer transport, including SMTP, Resend, SendGrid, and more. This was provided by default in Payload 2.x. This is the easiest migration path. 
 Resend     
 @payloadcms/email-resend 
 Resend email via their REST API. This is preferred for serverless platforms such as Vercel because it is much more lightweight than the nodemailer adapter.                                     
 Option                 
 Description                                                                                                                                                                            
 transport 
 The Nodemailer transport object for when you want to do it yourself, not needed when transportOptions is set                                                                           
 transportOptions 
 An object that configures the transporter that Payload will create. For all the available options see the Nodemailer documentation or see the examples below 
Simple Mail Transfer Protocol (SMTP) options can be passed in using the transportOptions object on the email options. See the Nodemailer SMTP documentation for more information, including details on when secure should and should not be set to true.
Example email options using SMTP:
Example email options using nodemailer.createTransport:
Custom Transport:
You also have the ability to bring your own nodemailer transport. This is an example of using the SendGrid nodemailer transport.
During development, if you pass nothing to nodemailerAdapter, it will use the ethereal.email service.
This will log the ethereal.email details to console on startup.
The Resend adapter requires an API key to be passed in the options. This can be found in the Resend dashboard. This is the preferred package if you are deploying on Vercel because this is much more lightweight than the Nodemailer adapter.
 Option 
 Description                         
 apiKey 
 The API key for the Resend service. 
With a working transport you can call it anywhere you have access to Payload by calling payload.sendEmail(message). The message will contain the to, subject and html or text for the email being sent. Other options are also available and can be seen in the sendEmail args. Support for these will depend on the adapter being used.
Payload supports the use of a single transporter of email, but there is nothing stopping you from having more. Consider a use case where sending bulk email is handled differently than transactional email and could be done using a hook.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/jobs-queue/overview

Payload's Jobs Queue gives you a simple, yet powerful way to offload large or future tasks to separate compute resources which is a very powerful feature of many application frameworks.
Non-blocking workloads
You might need to perform some complex, slow-running logic in a Payload Hook but you don't want that hook to "block" or slow down the response returned from the Payload API. Instead of running this logic directly in a hook, which would block your API response from returning until the expensive work is completed, you can queue a new Job and let it run at a later date.
Examples:
Scheduled actions
If you need to schedule an action to be run or processed at a certain date in the future, you can queue a job with the waitUntil property set. This will make it so the job is not "picked up" until that waitUntil date has passed.
Examples:
Periodic sync or similar scheduled action
Some applications may need to perform a regularly scheduled operation of some type. Jobs are perfect for this because you can execute their logic using cron, scheduled nightly, every twelve hours, or some similar time period.
Examples:
Offloading complex operations
You may run into the need to perform computationally expensive functions which might slow down your main Payload API server(s). The Jobs Queue allows you to offload these tasks to a separate compute resource rather than slowing down the server(s) that run your Payload APIs. With Payload Task definitions, you can even keep large dependencies out of your main Next.js bundle by dynamically importing them only when they are used. This keeps your Next.js + Payload compilation fast and ensures large dependencies do not get bundled into your Payload production build.
Examples:
There are a few concepts that you should become familiarized with before using Payload's Jobs Queue. We recommend learning what each of these does in order to fully understand how to leverage the power of Payload's Jobs Queue.
All of these pieces work together in order to allow you to offload long-running, expensive, or future scheduled work from your main APIs.
Here's a quick overview:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/jobs-queue/tasks

A "Task" is a function definition that performs business logic and whose input and output are both strongly typed.
You can register Tasks on the Payload config, and then create Jobs or Workflows that use them. Think of Tasks like tidy, isolated "functions that do one specific thing".
Payload Tasks can be configured to automatically retried if they fail, which makes them valuable for "durable" workflows like AI applications where LLMs can return non-deterministic results, and might need to be retried.
Tasks can either be defined within the jobs.tasks array in your Payload config, or they can be defined inline within a workflow.
Simply add a task to the jobs.tasks array in your Payload config. A task consists of the following fields:
 Option          
 Description                                                                                                                                                                                                                                                                                                                                                                                                                                      
 slug 
 Define a slug-based name for this job. This slug needs to be unique among both tasks and workflows.                                                                                                                                                                                                                                                                                                                                              
 handler 
 The function that should be responsible for running the job. You can either pass a string-based path to the job function file, or the job function itself. If you are using large dependencies within your job, you might prefer to pass the string path because that will avoid bundling large dependencies in your Next.js app. Passing a string path is an advanced feature that may require a sophisticated build pipeline in order to work. 
 inputSchema 
 Define the input field schema - Payload will generate a type for this schema.                                                                                                                                                                                                                                                                                                                                                                    
 interfaceName 
 You can use interfaceName to change the name of the interface that is generated for this task. By default, this is "Task" + the capitalized task slug.                                                                                                                                                                                                                                                                                           
 outputSchema 
 Define the output field schema - Payload will generate a type for this schema.                                                                                                                                                                                                                                                                                                                                                                   
 label 
 Define a human-friendly label for this task.                                                                                                                                                                                                                                                                                                                                                                                                     
 onFail 
 Function to be executed if the task fails.                                                                                                                                                                                                                                                                                                                                                                                                       
 onSuccess 
 Function to be executed if the task succeeds.                                                                                                                                                                                                                                                                                                                                                                                                    
 retries 
 Specify the number of times that this step should be retried if it fails. If this is undefined, the task will either inherit the retries from the workflow or have no retries. If this is 0, the task will not be retried. By default, this is undefined.                                                                                                                                                                                        
The logic for the Task is defined in the handler - which can be defined as a function, or a path to a function. The handler will run once a worker picks picks up a Job that includes this task.
It should return an object with an output key, which should contain the output of the task as you've defined.
Example:
In addition to defining handlers as functions directly provided to your Payload config, you can also pass an absolute path to where the handler is defined. If your task has large dependencies, and you are planning on executing your jobs in a separate process that has access to the filesystem, this could be a handy way to make sure that your Payload + Next.js app remains quick to compile and has minimal dependencies.
Keep in mind that this is an advanced feature that may require a sophisticated build pipeline, especially when using it in production or within Next.js, e.g. by calling opening the /api/payload-jobs/run endpoint. You will have to transpile the handler files separately and ensure they are available in the same location when the job is run. If you're using an endpoint to execute your jobs, it's recommended to define your handlers as functions directly in your Payload Config, or use import paths handlers outside of Next.js.
In general, this is an advanced use case. Here's how this would look:
payload.config.ts:
Then, the createPost file itself:
src/tasks/createPost.ts:
By default, if a task has passed previously and a workflow is re-run, the task will not be re-run. Instead, the output from the previous task run will be returned. This is to prevent unnecessary re-runs of tasks that have already passed.
You can configure this behavior through the retries.shouldRestore property. This property accepts a boolean or a function.
If shouldRestore is set to true, the task will only be re-run if it previously failed. This is the default behavior.
If shouldRestore this is set to false, the task will be re-run even if it previously succeeded, ignoring the maximum number of retries.
If shouldRestore is a function, the return value of the function will determine whether the task should be re-run. This can be used for more complex restore logic, e.g you may want to re-run a task up to X amount of times and then restore it for consecutive runs, or only re-run a task if the input has changed.
Example:
Example - determine whether a task should be restored based on the input data:
You can run sub-tasks within an existing task, by using the tasks or ìnlineTask arguments passed to the task handler function:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/jobs-queue/workflows

A "Workflow" is an optional way to combine multiple tasks together in a way that can be gracefully retried from the point of failure.
They're most helpful when you have multiple tasks in a row, and you want to configure each task to be able to be retried if they fail.
If a task within a workflow fails, the Workflow will automatically "pick back up" on the task where it failed and not re-execute any prior tasks that have already been executed.
The most important aspect of a Workflow is the handler, where you can declare when and how the tasks should run by simply calling the runTask function. If any task within the workflow, fails, the entire handler function will re-run.
However, importantly, tasks that have successfully been completed will simply re-return the cached and saved output without running again. The Workflow will pick back up where it failed and only task from the failure point onward will be re-executed.
To define a JS-based workflow, simply add a workflow to the jobs.workflows array in your Payload config. A workflow consists of the following fields:
 Option          
 Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
 slug 
 Define a slug-based name for this workflow. This slug needs to be unique among both tasks and workflows.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
 handler 
 The function that should be responsible for running the workflow. You can either pass a string-based path to the workflow function file, or workflow job function itself. If you are using large dependencies within your workflow, you might prefer to pass the string path because that will avoid bundling large dependencies in your Next.js app. Passing a string path is an advanced feature that may require a sophisticated build pipeline in order to work.                                                                                                                                                     
 inputSchema 
 Define the input field schema - Payload will generate a type for this schema.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
 interfaceName 
 You can use interfaceName to change the name of the interface that is generated for this workflow. By default, this is "Workflow" + the capitalized workflow slug.                                                                                                                                                                                                                                                                                                                                                                                                                                                       
 label 
 Define a human-friendly label for this workflow.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
 queue 
 Optionally, define the queue name that this workflow should be tied to. Defaults to "default".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
 retries 
 You can define retries on the workflow level, which will enforce that the workflow can only fail up to that number of retries. If a task does not have retries specified, it will inherit the retry count as specified on the workflow. You can specify 0 as workflow retries, which will disregard all task retry specifications and fail the entire workflow on any task failure. You can leave workflow retries as undefined, in which case, the workflow will respect what each task dictates as their own retry count. By default this is undefined, meaning workflows retries are defined by their tasks 
Example:
In the above example, our workflow was executing tasks that we already had defined in our Payload config. But, you can also run tasks without predefining them.
To do this, you can use the inlineTask function.
The drawbacks of this approach are that tasks cannot be re-used across workflows as easily, and the task data stored in the job will not be typed. In the following example, the inline task data will be stored on the job under job.taskStatus.inline['2'] but completely untyped, as types for dynamic tasks like these cannot be generated beforehand.
Example:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/jobs-queue/jobs

Now that we have covered Tasks and Workflows, we can tie them together with a concept called a Job.
Whereas you define Workflows and Tasks, which control your business logic, a Job is an individual instance of either a Task or a Workflow which contains many tasks.
For example, let's say we have a Workflow or Task that describes the logic to sync information from Payload to a third-party system. This is how you'd declare how to sync that info, but it wouldn't do anything on its own. In order to run that task or workflow, you'd create a Job that references the corresponding Task or Workflow.
Jobs are stored in the Payload database in the payload-jobs collection, and you can decide to keep a running list of all jobs, or configure Payload to delete the job when it has been successfully executed.
In order to queue a job, you can use the payload.jobs.queue function.
Here's how you'd queue a new Job, which will run a createPostAndUpdate workflow:
In addition to being able to queue new Jobs based on Workflows, you can also queue a job for a single Task:
Payload allows you to cancel jobs that are either queued or currently running. When cancelling a running job, the current task will finish executing, but no subsequent tasks will run. This happens because the job checks its cancellation status between tasks.
To cancel a specific job, use the payload.jobs.cancelByID method with the job's ID:
To cancel multiple jobs at once, use the payload.jobs.cancel method with a Where query:
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/jobs-queue/queues

Queues are the final aspect of Payload's Jobs Queue and deal with how to run your jobs. Up to this point, all we've covered is how to queue up jobs to run, but so far, we aren't actually running any jobs.
A Queue is a grouping of jobs that should be executed in order of when they were added.
When you go to run jobs, Payload will query for any jobs that are added to the queue and then run them. By default, all queued jobs are added to the default queue.
But, imagine if you wanted to have some jobs that run nightly, and other jobs which should run every five minutes.
By specifying the queue name when you queue a new job using payload.jobs.queue(), you can queue certain jobs with queue: 'nightly', and other jobs can be left as the default queue.
Then, you could configure two different runner strategies:
As mentioned above, you can queue jobs, but the jobs won't run unless a worker picks up your jobs and runs them. This can be done in four ways:
You can use the jobs.autoRun property to configure cron jobs:
autoRun is intended for use with a dedicated server that is always running, and should not be used on serverless platforms like Vercel.
You can execute jobs by making a fetch request to the /api/payload-jobs/run endpoint:
This endpoint is automatically mounted for you and is helpful in conjunction with serverless platforms like Vercel, where you might want to use Vercel Cron to invoke a serverless function that executes your jobs.
Vercel Cron Example
If you're deploying on Vercel, you can add a vercel.json file in the root of your project that configures Vercel Cron to invoke the run endpoint on a cron schedule.
Here's an example of what this file will look like:
The configuration above schedules the endpoint /api/payload-jobs/run to be invoked every 5 minutes.
The last step will be to secure your run endpoint so that only the proper users can invoke the runner.
To do this, you can set an environment variable on your Vercel project called CRON_SECRET, which should be a random string—ideally 16 characters or longer.
Then, you can modify the access function for running jobs by ensuring that only Vercel can invoke your runner.
This works because Vercel automatically makes the CRON_SECRET environment variable available to the endpoint as the Authorization header when triggered by the Vercel Cron, ensuring that the jobs can be run securely.
After the project is deployed to Vercel, the Vercel Cron job will automatically trigger the /api/payload-jobs/run endpoint in the specified schedule, running the queued jobs in the background.
If you want to process jobs programmatically from your server-side code, you can use the Local API:
Run all jobs:
Run a single job:
Finally, you can process jobs via the bin script that comes with Payload out of the box.
In addition, the bin script allows you to pass a --cron flag to the jobs:run command to run the jobs on a scheduled, cron basis:
By default, jobs are processed first in, first out (FIFO). This means that the first job added to the queue will be the first one processed. However, you can also configure the order in which jobs are processed.
You can configure the order in which jobs are processed in the jobs configuration by passing the processingOrder property. This mimics the Payload sort property that's used for functionality such as payload.find().
You can also set this on a queue-by-queue basis:
If you need even more control over the processing order, you can pass a function that returns the processing order - this function will be called every time a queue starts processing jobs.
You can configure the order in which jobs are processed in the payload.jobs.queue method by passing the processingOrder property.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/query-presets/overview

Query Presets allow you to save and share filters, columns, and sort orders for your Collections. This is useful for reusing common or complex filtering patterns and/or sharing them across your team.
Each Query Preset is saved as a new record in the database under the payload-query-presets collection. This allows for an endless number of preset configurations, where the users of your app define the presets that are most useful to them, rather than being hard coded into the Payload Config.
Within the Admin Panel, Query Presets are applied to the List View. When enabled, new controls are displayed for users to manage presets. Once saved, these presets can be loaded up at any time and optionally shared with others.
To enable Query Presets on a Collection, use the enableQueryPresets property in your Collection Config:
While not required, you may want to customize the behavior of Query Presets to suit your needs, such as add custom labels or access control rules.
Settings for Query Presets are managed on the queryPresets property at the root of your Payload Config:
The following options are available for Query Presets:
 Option        
 Description                                                                                                                     
 access 
 Used to define custom collection-level access control that applies to all presets. More details.             
 constraints 
 Used to define custom document-level access control that apply to individual presets. More details. 
 labels 
 Custom labels to use for the Query Presets collection.                                                                          
Query Presets are subject to the same Access Control as the rest of Payload. This means you can use the same patterns you are already familiar with to control who can read, update, and delete presets.
Access Control for Query Presets can be customized in two ways:
Collection-level access control applies to all presets within the Query Presets collection. Users cannot control these rules, they are written statically in your config.
To add Collection Access Control, use the queryPresets.access property in your Payload Config:
This example restricts all Query Presets to users with the role of admin.
Note: Custom access control will override the defaults on this collection, including the requirement for a user to be authenticated. Be sure to include any necessary checks in your custom rules unless you intend on making these publicly accessible.
You can also define access control rules that apply to each specific preset. Users have the ability to define and modify these rules on the fly as they manage presets. These are saved dynamically in the database on each document.
When a user manages a preset, document-level access control options will be available to them in the Admin Panel for each operation.
By default, Payload provides a set of sensible defaults for all Query Presets, but you can customize these rules to suit your needs:
You can augment the default access control rules with your own custom rules. This can be useful for creating more complex access control patterns that the defaults don't provide, such as for RBAC.
Adding custom access control rules requires:
To do this, use the queryPresets.constraints property in your Payload Config.
In this example, we've added a new option called Specific Roles that allows users to select from a list of roles. When this option is selected, the user will be prompted to select one or more roles from a list of options. The access control rule for this option is that the user operating on the preset must have one of the selected roles.
Note: Payload places your custom fields into the access[operation] field group, so your rules will need to reflect this.
The following options are available for each constraint:
 Option   
 Description                                                              
 label 
 The label to display in the dropdown for this constraint.                
 value 
 The value to store in the database when this constraint is selected.     
 fields 
 An array of fields to render when this constraint is selected.           
 access 
 A function that determines the access control rules for this constraint. 
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/typescript/overview

Payload supports TypeScript natively, and not only that, the entirety of the CMS is built with TypeScript. To get started developing with Payload and TypeScript, you can use one of Payload's built-in boilerplates in one line via create-payload-app:
Pick a TypeScript project type to get started easily.
It's also possible to set up a TypeScript project from scratch. We plan to write up a guide for exactly how—so keep an eye out for that, too.
Payload exports a number of types that you may find useful while writing your own custom functionality like Plugins, Hooks, Access Control functions, Custom Views, GraphQL queries / mutations or anything else.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/typescript/generating-types

While building your own custom functionality into Payload, like Plugins, Hooks, Access Control functions, Custom Views, GraphQL queries / mutations, or anything else, you may benefit from generating your own TypeScript types dynamically from your Payload Config itself.
Run the following command in a Payload project to generate types based on your Payload Config:
You can run this command whenever you need to regenerate your types, and then you can use these types in your Payload code directly.
By default, generate:types will add a declare statement to your types file, which automatically enables type inference within Payload.
If you are using your payload-types.ts file in other repos, though, it might be better to disable this declare statement, so that you don't get any TS errors in projects that use your Payload types, but do not have Payload installed.
If you do disable the declare pattern, you'll need to manually add a declare statement to your code in order for Payload types to be recognized. Here's an example showing how to declare your types in your payload.config.ts file:
You can specify where you want your types to be generated by adding a property to your Payload Config:
The above example places your types next to your Payload Config itself as the file generated-types.ts.
Payload generates your types based on a JSON schema. You can extend that JSON schema, and thus the generated types, by passing a function to typescript.schema:
This function takes the existing JSON schema as an argument and returns the modified JSON schema. It can be useful for plugins that wish to generate their own types.
For example, let's look at the following simple Payload Config:
By generating types, we'll end up with a file containing the following two TypeScript interfaces:
For array, block, group and named tab fields, you can generate top level reusable interfaces. The following group field config:
will generate:
 Naming Collisions
Since these types are hoisted to the top level, you need to be aware that naming collisions can occur. For example, if you have a collection with the name of Meta and you also create a interface with the name Meta they will collide. It is recommended to scope your interfaces by appending the field type to the end, i.e. MetaGroup or similar.
Now that your types have been generated, Payload's Local API will now be typed. It is common for users to want to use this in their frontend code, we recommend generating them with Payload and then copying the file over to your frontend codebase. This is the simplest way to get your types into your frontend codebase.
 Important
Payload needs to be able to find your config to generate your types.
Payload will automatically try and locate your config, but might not always be able to find it. For example, if you are working in a /src directory or similar, you need to tell Payload where to find your config manually by using an environment variable. If this applies to you, you can create an npm script to make generating your types easier.
To add an npm script to generate your types and show Payload where to find your config, open your package.json and update the scripts property to the following:
Now you can run pnpm generate:types to easily generate your types.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/production/deployment

So you've developed a Payload app, it's fully tested, and running great locally. Now it's time to launch. Awesome! Great work! Now, what's next?
There are many ways to deploy Payload to a production environment. When evaluating how you will deploy Payload, you need to consider these main aspects:
Payload can be deployed anywhere that Next.js can run - including Vercel, Netlify, SST, DigitalOcean, AWS, and more. Because it's open source, you can self-host it.
But it's important to remember that most Payload projects will also need a database, file storage, an email provider, and a CDN. Make sure you have all of the requirements that your project needs, no matter what deployment platform you choose.
Often, the easiest and fastest way to deploy Payload is to use Payload Cloud — where you get everything you need out of the box, including:
Payload runs fully in Next.js, so the Next.js build process is used for building Payload. If you've used create-payload-app to create your project, executing the build npm script will build Payload for production.
Payload features a suite of security features that you can rely on to strengthen your application's security. When deploying to Production, it's a good idea to double-check that you are making proper use of each of them.
When you initialize Payload, you provide it with a secret property. This property should be impossible to guess and extremely difficult for brute-force attacks to crack. Make sure your Production secret is a long, complex string.
Because you are in complete control of who can do what with your data, you should double and triple-check that you wield that power responsibly before deploying to Production.
By default, all Access Control functions require that a user is successfully logged in to Payload to create, read, update, or delete data.
But, if you allow public user registration, for example, you will want to make sure that your access control functions are more strict - permitting only appropriate users to perform appropriate actions.
Depending on where you deploy Payload, you may need to provide a start script to your deployment platform in order to start up Payload in production mode.
Note that this is different than running next dev. Generally, Next.js apps come configured with a start script which runs next start.
You should be using an SSL certificate for production Payload instances, which means you can enable secure cookies in your Authentication-enabled Collection configs.
Payload comes with a robust set of built-in anti-abuse measures, such as locking out users after X amount of failed login attempts, GraphQL query complexity limits, max depth settings, and more. Click here to learn more.
Payload can be used with any Postgres database or MongoDB-compatible database including AWS DocumentDB or Azure Cosmos DB. Make sure your production environment has access to the database that Payload uses.
Out of the box, Payload templates pass the process.env.DATABASE_URI environment variable to its database adapters, so make sure you've got that environment variable (and all others that you use) assigned in your deployment platform.
When using AWS DocumentDB, you will need to configure connection options for authentication in the connectOptions passed to the mongooseAdapter . You also need to set connectOptions.useFacet to false to disable use of the unsupported $facet aggregation.
When using Azure Cosmos DB, an index is needed for any field you may want to sort on. To add the sort index for all fields that may be sorted in the admin UI use the indexSortableFields option.
If you are using Payload to manage file uploads, you need to consider where your uploaded files will be permanently stored. If you do not use Payload for file uploads, then this section does not impact your app whatsoever.
Some cloud app hosts such as Heroku use ephemeral file systems, which means that any files uploaded to your server only last until the server restarts or shuts down. Heroku and similar providers schedule restarts and shutdowns without your control, meaning your uploads will accidentally disappear without any way to get them back.
Alternatively, persistent filesystems will never delete your files and can be trusted to reliably host uploads perpetually.
Popular cloud providers with ephemeral filesystems:
Popular cloud providers with persistent filesystems:
 Warning:
If you rely on Payload's Upload functionality, make sure you either use a host with a persistent filesystem or have an integration with a third-party file host like Amazon S3.
If you don't use Payload's upload functionality, you can completely disregard this section.
But, if you do, and you still want to use an ephemeral filesystem provider, you can use one of Payload's official cloud storage plugins or write your own to save the files your users upload to a more permanent storage solution like Amazon S3 or DigitalOcean Spaces.
Payload provides a list of official cloud storage adapters for you to use:
Follow the docs to configure any one of these storage providers. For local development, it might be handy to simply store uploads on your own computer, and then when it comes to production, simply enable the plugin for the cloud storage vendor of your choice.
This is an example of a multi-stage docker build of Payload for production. Ensure you are setting your environment variables on deployment, like PAYLOAD_SECRET, PAYLOAD_CONFIG_PATH, and DATABASE_URI if needed.
In your Next.js config, set the output property standalone.
Dockerfile
Here is an example of a docker-compose.yml file that can be used for development
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

URL: https://payloadcms.com/docs/production/preventing-abuse

Payload has built-in security best practices that can be configured to your application-specific needs.
Set the max number of failed login attempts before a user account is locked out for a period of time. Set the maxLoginAttempts on the collections that feature Authentication to a reasonable but low number for your users to get in. Use the lockTime to set a number in milliseconds from the time a user fails their last allowed attempt that a user must wait to try again.
Querying a collection and automatically including related documents via depth incurs a performance cost. Also, it's possible that your configs may have circular relationships, meaning scenarios where an infinite amount of relationships might populate back and forth until your server times out and crashes. You can prevent any potential of depth-related issues by setting a maxDepth property on your Payload Config.. The maximum allowed depth should be as small as possible without interrupting dev experience, and it defaults to 10.
CSRF prevention will verify the authenticity of each request to your API to prevent a malicious action from another site from authorized users. See how to configure CSRF here.
To securely allow headless operation you will need to configure the allowed origins for requests to be able to use the Payload API. You can see how to set CORS as well as other Payload configuration settings here
Because GraphQL gives the power of query writing outside a server's control, someone with bad intentions might write a maliciously complex query and bog down your server. To prevent resource-intensive GraphQL requests, Payload provides a way to specify complexity limits. These limits are based on a complexity score calculated for each request.
Any GraphQL request that is calculated to be too expensive is rejected. On the Payload Config, in graphQL you can set the maxComplexity value as an integer. For reference, the default complexity value for each added field is 1, and all relationship and upload fields are assigned a value of 10.
If you do not need GraphQL it is advised that you disable it altogether with the Payload Config by setting graphQL.disable: true. Should you wish to enable GraphQL again, you can remove this property or set it false, any time. By turning it off, Payload will bypass creating schemas from your collections and will not register the route.
Payload does not execute uploaded files on the server, but depending on your setup it may be used to transmit and store potentially dangerous files. If your configuration allows file uploads there is the potential that a bad actor uploads a malicious file that is then served to other users. Consider the following ways to mitigate the risks.
First, enable email verification when users are allowed to register new accounts and add other bot prevention services.
Review that create and update access on file upload collections are as restrictive as your application needs allow. Consider limiting read access of uploaded user's files and how you might limit user uploaded files from being served outside of Payload.
You can also add a 3rd party library to scan files in a hook or have antivirus software in place.
Star
Discord
 online
Use Cases
Developers
Company
Stay connected

================================================================================

